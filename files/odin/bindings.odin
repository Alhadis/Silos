package libjit

import "core:os"

when os.OS == "linux"   do foreign import libjit "system:jit";
else                    do #assert(false); // TODO!!!

@(default_calling_convention="c", link_prefix="jit_")
foreign libjit {
    jit_type_void: Type;
    jit_type_sbyte: Type;
    jit_type_ubyte: Type;
    jit_type_short: Type;
    jit_type_ushort: Type;
    jit_type_int: Type;
    jit_type_uint: Type;
    jit_type_long: Type;
    jit_type_ulong: Type;
    jit_type_float32: Type;
    jit_type_float64: Type;
    jit_type_nfloat: Type;
    jit_type_void_ptr: Type;

    init                                        :: proc() ---;
    uses_interpreter                            :: proc() -> i32 ---;
    supports_threads                            :: proc(ctx: Context) -> i32 ---;
    context_create                              :: proc() -> Context ---;
    context_destroy                             :: proc(ctx: Context) ---;
    context_build_start                         :: proc(ctx: Context) ---;
    context_build_end                           :: proc(ctx: Context) ---;
    context_set_on_demand_driver                :: proc(ctx: Context, driver: On_Demand_Driver_Proc) ---;
    context_set_meta                            :: proc(ctx: Context, type: i32, data: rawptr, free_proc: Meta_Free_Proc) ---;
    context_set_meta_numeric                    :: proc(ctx: Context, type: i32, data: u64) ---;
    context_get_meta                            :: proc(ctx: Context, type: i32) -> rawptr ---;
    context_get_meta_numeric                    :: proc(ctx: Context, type: i32) -> u64 ---;
    context_free_meta                           :: proc(ctx: Context, type: i32) ---;
    function_create                             :: proc(ctx: Context, signature: Type) -> Function ---;
    function_create_nested                      :: proc(ctx: Context, signature: Type, parent: Function) -> Function ---;
    function_abandon                            :: proc(func: Function) ---;
    function_get_context                        :: proc(func: Function) -> Context ---;
    function_get_signature                      :: proc(func: Function) -> Type ---;
    function_set_meta                           :: proc(func: Function, type: i32, data: rawptr, free_proc: Meta_Free_Proc, build_only: i32) ---;
    function_get_meta                           :: proc(func: Function, type: i32) -> rawptr ---;
    function_free_meta                          :: proc(func: Function, type: i32) ---;
    function_next                               :: proc(ctx: Context, prev: Function) -> Function ---;
    function_previous                           :: proc(ctx: Context, prev: Function) -> Function ---;
    function_get_entry                          :: proc(func: Function) -> Block ---;
    function_get_current                        :: proc(func: Function) -> Block ---;
    function_get_nested_parent                  :: proc(func: Function) -> Function ---;
    function_compile                            :: proc(func: Function) -> i32 ---;
    function_compile_entry                      :: proc(func: Function, entry_point: rawptr) -> i32 ---;
    function_entry_setup                        :: proc(func: Function, entry_point: rawptr) -> i32 ---;
    function_is_compiled                        :: proc(func: Function) -> i32 ---;
    function_set_recompilable                   :: proc(func: Function) ---;
    function_clear_recompilable                 :: proc(func: Function) ---;
    function_is_recompilable                    :: proc(func: Function) -> i32 ---;
    function_to_closure                         :: proc(func: Function) -> rawptr ---;
    function_from_closure                       :: proc(ctx: Context, closure: rawptr) -> Function ---;
    function_from_pc                            :: proc(ctx: Context, pc, handler: rawptr) -> Function ---;
    function_to_vtable_pointer                  :: proc(func: Function) -> rawptr ---;
    function_from_vtable_pointer                :: proc(ctx: Context, vtable_pointer: rawptr) -> Function ---;
    function_set_on_demand_compiler             :: proc(func: Function, on_demand: On_Demand_Proc) ---;
    function_get_on_demand_compiler             :: proc(func: Function) -> On_Demand_Driver_Proc ---;
    function_apply                              :: proc(func: Function, args, return_area: rawptr) -> i32 ---;
    function_apply_vararg                       :: proc(func: Function, signature: Type, args, return_area: rawptr) -> i32 ---;
    function_set_optimization_level             :: proc(func: Function, level: u32) ---;
    function_get_optimization_level             :: proc(func: Function) -> u32 ---;
    function_get_max_optimization_level         :: proc(func: Function) -> u32 ---;
    function_reserve_label                      :: proc(func: Function) -> Label ---;
    type_copy                                   :: proc(type: Type) -> Type ---;
    type_free                                   :: proc(type: Type) ---;
    type_create_struct                          :: proc(fields: ^Type, num_fields: u32, incref: i32) -> Type ---;
    type_create_union                           :: proc(fields: ^Type, num_fields: u32, incref: i32) -> Type ---;
    type_create_signature                       :: proc(abi: Abi, return_type: Type, params: ^Type, num_params: u32, incref: i32) -> Type ---;
    type_create_pointer                         :: proc(type: Type, incref: i32) -> Type ---;
    type_create_tagged                          :: proc(type: Type, kind: i32, data: rawptr, free_proc: Meta_Free_Proc, incref: i32) -> Type ---;
    type_set_names                              :: proc(type: Type, names: ^cstring, num_names: u32) -> i32 ---;
    type_set_size_and_alignment                 :: proc(type: Type, size, alignment: u64) ---;
    type_set_offset                             :: proc(type: Type, field_index: u32, offset: u64) ---;
    type_get_kind                               :: proc(type: Type) -> i32 ---;
    type_get_size                               :: proc(type: Type) -> u64 ---;
    type_get_alignment                          :: proc(type: Type) -> u64 ---;
    type_num_fields                             :: proc(type: Type) -> u32 ---;
    type_get_field                              :: proc(type: Type, field_index: u32) -> Type ---;
    type_get_offset                             :: proc(type: Type, field_index: u32) -> u64 ---;
    type_get_name                               :: proc(type: Type, index: u32) -> cstring ---;
    type_find_name                              :: proc(type: Type, name: cstring) -> u32 ---;
    type_num_params                             :: proc(type: Type) -> u32 ---;
    type_get_return                             :: proc(type: Type) -> Type ---;
    type_get_param                              :: proc(type: Type, param_index: u32) -> Type ---;
    type_get_abi                                :: proc(type: Type) -> Abi ---;
    type_get_ref                                :: proc(type: Type) -> Type ---;
    type_get_tagged_type                        :: proc(type: Type) -> Type ---;
    type_set_tagged_type                        :: proc(type: Type, underlying: Type) ---;
    type_get_tagged_data                        :: proc(type: Type) -> rawptr ---;
    type_set_tagged_data                        :: proc(type: Type, data: rawptr, free_proc: Meta_Free_Proc) ---;
    type_is_primitive                           :: proc(type: Type) -> i32 ---;
    type_is_struct                              :: proc(type: Type) -> i32 ---;
    type_is_union                               :: proc(type: Type) -> i32 ---;
    type_is_signature                           :: proc(type: Type) -> i32 ---;
    type_is_pointer                             :: proc(type: Type) -> i32 ---;
    type_is_tagged                              :: proc(type: Type) -> i32 ---;
    type_best_alignment                         :: proc() -> u64 ---;
    type_normalize                              :: proc(type: Type) -> Type ---;
    type_remove_tags                            :: proc(type: Type) -> Type ---;
    type_promote_int                            :: proc(type: Type) -> Type ---;
    type_return_via_pointer                     :: proc(type: Type) -> i32 ---;
    type_has_tag                                :: proc(type: Type) -> i32 ---;
    value_create                                :: proc(func: Function, type: Type) -> Value ---;
    value_create_nint_constant                  :: proc(func: Function, type: Type, value: i64) -> Value ---;
    value_create_long_constant                  :: proc(func: Function, type: Type, value: i64) -> Value ---;
    value_create_float32_constant               :: proc(func: Function, type: Type, value: f32) -> Value ---;
    value_create_float64_constant               :: proc(func: Function, type: Type, value: f64) -> Value ---;
    value_create_nfloat_constant                :: proc(func: Function, type: Type, value: f64) -> Value ---;
    value_get_param                             :: proc(func: Function, param: u32) -> Value ---;
    value_get_struct_pointer                    :: proc(func: Function) -> Value ---;
    value_is_temporary                          :: proc(value: Value) -> i32 ---;
    value_is_local                              :: proc(value: Value) -> i32 ---;
    value_is_constant                           :: proc(value: Value) -> i32 ---;
    value_is_parameter                          :: proc(value: Value) -> i32 ---;
    value_ref                                   :: proc(func: Function, value: Value) ---;
    value_set_volatile                          :: proc(value: Value) ---;
    value_is_volatile                           :: proc(value: Value) -> i32 ---;
    value_set_addressable                       :: proc(value: Value) ---;
    value_is_addressable                        :: proc(value: Value) ---;
    value_get_type                              :: proc(value: Value) -> Type ---;
    value_get_function                          :: proc(value: Value) -> Function ---;
    value_get_block                             :: proc(value: Value) -> Block ---;
    value_get_context                           :: proc(value: Value) -> Context ---;
    value_get_nint_constant                     :: proc(value: Value) -> i64 ---;
    value_get_long_constant                     :: proc(value: Value) -> i64 ---;
    value_get_float32_constant                  :: proc(value: Value) -> f32 ---;
    value_get_float64_constant                  :: proc(value: Value) -> f64 ---;
    value_get_nfloat_constant                   :: proc(value: Value) -> f64 ---;
    value_is_true                               :: proc(value: Value) -> i32 ---;
    insn_get_opcode                             :: proc(insn: Insn) -> i32 ---;
    insn_get_dest                               :: proc(insn: Insn) -> Value ---;
    insn_get_value1                             :: proc(insn: Insn) -> Value ---;
    insn_get_value2                             :: proc(insn: Insn) -> Value ---;
    insn_get_label                              :: proc(insn: Insn) -> Label ---;
    insn_get_function                           :: proc(insn: Insn) -> Function ---;
    insn_get_native                             :: proc(insn: Insn) -> rawptr ---;
    insn_get_name                               :: proc(insn: Insn) -> cstring ---;
    insn_get_signature                          :: proc(insn: Insn) -> Type ---;
    insn_dest_is_value                          :: proc(insn: Insn) -> i32 ---;
    insn_label                                  :: proc(insn: Insn, label: ^Label) ---;
    insn_new_block                              :: proc(func: Function) -> i32 ---;
    insn_load                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_dup                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_load_small                             :: proc(func: Function, value: Value) -> Value ---;
    insn_store                                  :: proc(func: Function, dest, value: Value) ---;
    insn_load_relative                          :: proc(func: Function, value: Value, offset: i64, type: Type) -> Value ---;
    insn_store_relative                         :: proc(func: Function, dest: Value, offset: i64, value: Value) -> i32 ---;
    insn_add_relative                           :: proc(func: Function, value: Value, offset: i64) -> Value ---;
    insn_load_elem                              :: proc(func: Function, base_addr, index: Value, elem_type: Type) -> Value ---;
    insn_load_elem_address                      :: proc(func: Function, base_addr, index: Value, elem_type: Type) -> Value ---;
    insn_store_elem                             :: proc(func: Function, base_addr, index, value: Value) -> i32 ---;
    insn_check_null                             :: proc(func: Function, value: Value) -> i32 ---;
    insn_add                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_add_ovf                                :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_sub                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_sub_ovf                                :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_mul                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_mul_ovf                                :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_div                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_rem                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_rem_ieee                               :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_neg                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_and                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_or                                     :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_xor                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_not                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_shl                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_shr                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_ushr                                   :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_eq                                     :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_ne                                     :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_lt                                     :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_gt                                     :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_le                                     :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_ge                                     :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_cmpl                                   :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_cmpg                                   :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_to_bool                                :: proc(func: Function, value: Value) -> Value ---;
    insn_to_not_bool                            :: proc(func: Function, value: Value) -> Value ---;
    insn_acos                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_asin                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_atan                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_atan2                                  :: proc(func: Function, value: Value) -> Value ---;
    insn_ceil                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_cos                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_cosh                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_exp                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_floor                                  :: proc(func: Function, value: Value) -> Value ---;
    insn_log                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_log10                                  :: proc(func: Function, value: Value) -> Value ---;
    insn_pow                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_rint                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_round                                  :: proc(func: Function, value: Value) -> Value ---;
    insn_sin                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_sinh                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_sqrt                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_tan                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_tanh                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_is_nan                                 :: proc(func: Function, value: Value) -> Value ---;
    insn_is_finite                              :: proc(func: Function, value: Value) -> Value ---;
    insn_is_inf                                 :: proc(func: Function, value: Value) -> Value ---;
    insn_abs                                    :: proc(func: Function, value: Value) -> Value ---;
    insn_max                                    :: proc(func: Function, value1, value2: Value) -> Value ---;
    insn_sign                                   :: proc(func: Function, value: Value) -> Value ---;
    insn_branch                                 :: proc(func: Function, label: ^Label) -> i32 ---;
    insn_branch_if                              :: proc(func: Function, value: Value, label: ^Label) -> i32 ---;
    insn_branch_if_not                          :: proc(func: Function, value: Value, label: ^Label) -> i32 ---;
    insn_jump_table                             :: proc(func: Function, value: Value, labels: ^Label, num_labels: u32) -> i32 ---;
    insn_address_of                             :: proc(func: Function, value: Value) -> Value ---;
    insn_address_of_label                       :: proc(func: Function, label: Label) -> Value ---;
    insn_convert                                :: proc(func: Function, value: Value, type: Type, overflow_check: i32) -> Value ---;
    insn_call                                   :: proc(func: Function, name: cstring, jit_func: Function, signature: Type, args: ^Value, num_args: u32, flags: Call_Flags) -> Value ---;
    insn_call_indirect                          :: proc(func: Function, value: Value, signature: Type, args: ^Value, num_args: u32, flags: Call_Flags) -> Value ---;
    insn_call_indirect_vtable                   :: proc(func: Function, value: Value, signature: Type, args: ^Value, num_args: u32, flags: Call_Flags) -> Value ---;
    insn_call_native                            :: proc(func: Function, name: cstring, native_func: rawptr, signature: Type, args: ^Value, num_args: u32, exception_return: i32, flags: Call_Flags) -> Value ---;
    insn_import                                 :: proc(func: Function, value: Value) -> Value ---;
    insn_return                                 :: proc(func: Function, value: Value) -> i32 ---;
    insn_return_ptr                             :: proc(func: Function, value: Value, type: Type) -> i32 ---;
    insn_default_return                         :: proc(func: Function) -> i32 ---;
    insn_memcpy                                 :: proc(func: Function, dest, src, size: Value) -> i32 ---;
    insn_memmove                                :: proc(func: Function, dest, src, size: Value) -> i32 ---;
    insn_memset                                 :: proc(func: Function, dest, value, size: Value) -> i32 ---;
    insn_alloca                                 :: proc(func: Function, size: Value) -> Value ---;
}