@Module 
package java.lang; 

import java.util.Arrays;
import java.util.Iterator;
import java.util.Objects;

import org.w3c.dom.Node;
import org.w3c.html.HTMLElement;
 
public final class Class<T> {
  
	public static final int CLASS = 0x1;
	public static final int INTERFACE = 0x2;
	public static final int ENUM = 0x4;
	 
	public static final int ARRAY = 0x10; 
	public static final int PRIMITIVE = 0x20; 
	   
	private static int __index; 
	private final String _name;
	private transient final int _id;   
	private transient final Class<?>[] _interfaces; 
	private transient final Class<? super T> _superClass; 
	private transient final int _flags;
	private transient final Object _factory;   
	
	public Class(String name, Object factory, Class<? super T> superClass, Class<?>[] interfaces, int flags) {
		this._name = name; 
		this._factory = factory; 
		this._id = __index++;
		this._flags = flags; 
		this._interfaces = interfaces;
		this._superClass = superClass;
	}
	public String toString() { 
		return (isInterface ? "interface " : (isPrimitive ? "" : "class ")) + name;
	}
	public boolean isInstance(Object obj){
		if (obj == null)
			return false; 

		return this.isAssignableFrom(obj.getClass());
	}
	public boolean isAssignableFrom(Class<?> cls){
		if (cls == null)
			return false; 

		if (this == cls)
			return true; 

		if (cls.isSubclassOf(this)) 
			return true; 

		if (this.isInterface) 
		{
			return cls.implementInterface(this);
		}

		return false;
 	}
  
	public Class<?> superClass{
		&{
			return this._superClass;
		}
	}
	
	public boolean isSubclassOf(Class<?> c)
	{
		Class<?> p = this;
	    if (p == c) 
	      return false;
	    while (p != null) { 
	      if (p == c)
	        return true;
	      p = p.superClass;
	    } 
	    return false;
	}
  
	public boolean implementInterface(Class<?> ifaceType) 
	{ 
	  	Class<?> t = this;
	    while (t != null) { 
	    	Class<?>[] interfaces = t.interfaces;
	    	if (interfaces != null) { 
	    		for (int i = 0; i < interfaces.length; i++){ 
	    			// Interfaces don't derive from other interfaces, they implement them.
	    			// So instead of IsSubclassOf, we should use ImplementInterface instead.
	    			if (interfaces[i] == ifaceType || (interfaces[i] != null && interfaces[i].implementInterface(ifaceType))) 
	    				return true;
	    		} 
	    	} 
	
	    	t = t.superClass; 
    	}

    	return false;
 	}
	
	public Object factory {
		&{
			return this._factory;
		}
	}
  
	// This property will return all of the interfaces implemented by a class 
	public Class<?>[] interfaces{
		&{
			return this._interfaces;
		}
	}
  
	public String name{
		&{
			return this._name;
		}
	}
  
	public int id{
		&{
			return this._id;
		}
	}

	public boolean isInterface{
		&{
			return (this._flags & INTERFACE) != 0; 
		}
	}
	
	public boolean isArray{
		&{
			return (this._flags & ARRAY) != 0;
		}
	}
	
	public boolean isEnum{
		&{
			return (this._flags & ENUM) != 0;
		}
	}

	public boolean isPrimitive{
		&{
			return (this._flags & PRIMITIVE) != 0;
		}
	}
  
	public int hashCode(){
		return this._id;
	}
  
	public native Object newInstance()/*-{
	  	return new (this._factory)();
  	}-*/;
}


public native class Object { 
	static{
		registerPrimitiveClass();
	}
	public native Object();
	private native static void registerPrimitiveClass() /*-{
		var c = __lc('java.lang.Class');
		__cache["<B"] = new c("<B", null, Object.prototype.__class, [], 0x21);
		__cache["<C"] = new c("<C", null, Object.prototype.__class, [], 0x21);
		__cache["<S"] = new c("<B", null, Object.prototype.__class, [], 0x21);
		__cache["<I"] = new c("<B", null, Object.prototype.__class, [], 0x21);
		__cache["<L"] = new c("<B", null, Object.prototype.__class, [], 0x21);
		__cache["<F"] = new c("<B", null, Object.prototype.__class, [], 0x21);
		__cache["<D"] = new c("<B", null, Object.prototype.__class, [], 0x21);
		__cache["<Z"] = new c("<B", null, Object.prototype.__class, [], 0x21);
		
	}-*/; 
	public native Object(Object value);
	
	public native Object this[String name];
	
	public static native Object create(Object prototype, Object descriptors);
	
	public static native Object defineProperties(Object obj, Object descriptors);
	
	public static native Object defineProperty(Object obj, String name, Object descriptor);
	public native static void freeze(Object object); 
	public static native Object getOwnPropertyDescriptor(Object object, String propertyname);
	public static native String[] getOwnPropertyNames();  

	public static native boolean isExtensible(Object object);  
	public static native boolean isFrozen(Object object); 
	public static native boolean isSealed(Object object);   
	 
	public static native String[] keys(Object object);  
	
	public static native void preventExtensions(Object object); 
	
	public static native void seal(Object object); 
	public static native Object getPrototypeOf(); 
	
	public native boolean hasOwnProperty(String propName);

	public native String toString();
	public native String toLocaleString();
	
	public native boolean isPrototypeOf(Object object);
	public native boolean propertyIsEnumerable(String proName);
	
	public native Object valueOf();
	
	public native Object prototype{}
	
	public native Function constructor{}
	
	public native Object __proto__{}

	
	public int hashCode(){
		return 0;
	}
	
	public native Class<? extends Object> getClass()/*-
	{
		return this.__class; 
	}
	-*/;
	
	public boolean equals(Object that) {
		if(this == that){
			return true;
		}
		
		return false;
	}
	
  /**
   * Creates and returns a copy of this object. The precise meaning
   * of "copy" may depend on the class of the object. The general
   * intent is that, for any object {@code x}, the expression:
   * <blockquote>
   * <pre>
   * x.clone() != x</pre></blockquote>
   * will be true, and that the expression:
   * <blockquote>
   * <pre>
   * x.clone().getClass() == x.getClass()</pre></blockquote>
   * will be {@code true}, but these are not absolute requirements.
   * While it is typically the case that:
   * <blockquote>
   * <pre>
   * x.clone().equals(x)</pre></blockquote>
   * will be {@code true}, this is not an absolute requirement.
   * <p>
   * By convention, the returned object should be obtained by calling
   * {@code super.clone}. If a class and all of its superclasses (except
   * {@code Object}) obey this convention, it will be the case that
   * {@code x.clone().getClass() == x.getClass()}.
   * <p>
   * By convention, the object returned by this method should be independent
   * of this object (which is being cloned). To achieve this independence,
   * it may be necessary to modify one or more fields of the object returned
   * by {@code super.clone} before returning it. Typically, this means
   * copying any mutable objects that comprise the internal "deep structure"
   * of the object being cloned and replacing the references to these
   * objects with references to the copies. If a class contains only
   * primitive fields or references to immutable objects, then it is usually
   * the case that no fields in the object returned by {@code super.clone}
   * need to be modified.
   * <p>
   * The method {@code clone} for class {@code Object} performs a
   * specific cloning operation. First, if the class of this object does
   * not implement the interface {@code Cloneable}, then a
   * {@code CloneNotSupportedException} is thrown. Note that all arrays
   * are considered to implement the interface {@code Cloneable} and that
   * the return type of the {@code clone} method of an array type {@code T[]}
   * is {@code T[]} where T is any reference or primitive type.
   * Otherwise, this method creates a new instance of the class of this
   * object and initializes all its fields with exactly the contents of
   * the corresponding fields of this object, as if by assignment; the
   * contents of the fields are not themselves cloned. Thus, this method
   * performs a "shallow copy" of this object, not a "deep copy" operation.
   * <p>
   * The class {@code Object} does not itself implement the interface
   * {@code Cloneable}, so calling the {@code clone} method on an object
   * whose class is {@code Object} will result in throwing an
   * exception at run time.
   *
   * @return   a clone of this instance.
   * @throws CloneNotSupportedException if the object's class does not
   *        support the {@code Cloneable} interface. Subclasses
   *        that override the {@code clone} method can also
   *        throw this exception to indicate that an instance cannot
   *        be cloned.
   * @see java.lang.Cloneable
   */
  protected Object clone() throws CloneNotSupportedException{
		return __proto__;
  	
  }
  public static boolean equals(Object left, Object right) {
	  return false;
  }
}

public abstract class Throwable {
    public String message{}
    public String description{};

}

public native class Error extends Throwable{

	public native Error();
	
	public native Error(int number);
	
	public native Error(int number, String message);
	public native String description{}
	public native String message {}
	public native String name{}
	public native Number number{}
	public native Object prototype{}

	public native Object stack{}
	public native Object stackTraceLimit{}
	
	public native String valueOf();
}

public native class Array<T> {  

	public native Array();
	public native Array(int size);
	public native Array(Object ... elements);
	
	public T this[int index];   
	public native int length{}
	
	public native Array<T> slice();  
	
	public static native boolean isArray(Object object);
	
	public native Array<T> concat(T ... item); 
	
	public native boolean every(ArrayCallback<T> callback);
	
	public native boolean every(ArrayCallback<T> callback, Object context);
	
	public native Array<T> filter(ArrayCallback<T> callback);
	
	public native Array<T> filter(ArrayCallback<T> callback, Object context);
	
	public native void forEach(ArrayCallback<T> callback);
	 
	public native void forEach(ArrayCallback<T> callback, Object context);
	
	public native int indexOf(T searchElement);
	
	public native int indexOf(T searchElement, int fromIndex); 
	 
	public native String join();
	 
	public native String join(String separator); 
	
	public native int lastIndexOf(T searchElement);
	
	public native int lastIndexOf(T searchElement, int fromIndex);
	
	public native Array<T> map(ArrayCallback callbackfn);
	
	public native T pop();
	
	public native int push(T ... item);
	
	public native int reduce(ReduceCallback<T> callbackfn);
	
	public native int reduce(ReduceCallback<T> callbackfn, int initialValue);
	
	public native Object reduceRight(ReduceCallback<T> callbackfn);
	
	public native Object reduceRight(ReduceCallback<T> callbackfn, int initialValue);
	
	public native Array<T> reverse();
	
	public native T shift();
	
	public native Array<T> slice(int start);
	
	public native Array<T> slice(int start, int end);
	
	public native boolean some(ArrayCallback<T> callbackfn);
	
	public native boolean some(ArrayCallback<T> callbackfn, Object thisContext);
	
	public native Array<T> sort(Comparator<T> sortFunction);
	
	public native Array<T> splice(int start, int deleteCount);
	
	public native Array<T> splice(int start, int deleteCount, T ... items);
	
	public native void unshift(T ... item);
	
	public native Array<T> valueOf();
}

public function void ArrayCallback<T>(T value, int index, Array<T> array);

public function void ReduceCallback<T>(T previousValue, T currentValue, int currentIndex, Array<T> array);

/**
 * Compares this object with the specified object for order.  Returns a
 * negative integer, zero, or a positive integer as this object is less
 * than, equal to, or greater than the specified object.
 *
 * <p>The implementor must ensure <tt>sgn(x.compareTo(y)) ==
 * -sgn(y.compareTo(x))</tt> for all <tt>x</tt> and <tt>y</tt>.  (This
 * implies that <tt>x.compareTo(y)</tt> must throw an exception iff
 * <tt>y.compareTo(x)</tt> throws an exception.)
 *
 * <p>The implementor must also ensure that the relation is transitive:
 * <tt>(x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0)</tt> implies
 * <tt>x.compareTo(z)&gt;0</tt>.
 *
 * <p>Finally, the implementor must ensure that <tt>x.compareTo(y)==0</tt>
 * implies that <tt>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</tt>, for
 * all <tt>z</tt>.
 *
 * <p>It is strongly recommended, but <i>not</i> strictly required that
 * <tt>(x.compareTo(y)==0) == (x.equals(y))</tt>.  Generally speaking, any
 * class that implements the <tt>Comparable</tt> interface and violates
 * this condition should clearly indicate this fact.  The recommended
 * language is "Note: this class has a natural ordering that is
 * inconsistent with equals."
 *
 * <p>In the foregoing description, the notation
 * <tt>sgn(</tt><i>expression</i><tt>)</tt> designates the mathematical
 * <i>signum</i> function, which is defined to return one of <tt>-1</tt>,
 * <tt>0</tt>, or <tt>1</tt> according to whether the value of
 * <i>expression</i> is negative, zero or positive.
 *
 * @param   o the object to be compared.
 * @return  a negative integer, zero, or a positive integer as this object
 *          is less than, equal to, or greater than the specified object.
 *
 * @throws NullPointerException if the specified object is null
 * @throws ClassCastException if the specified object's type prevents it
 *         from being compared to this object.
 */
public function int Comparator<T>(T o1, T o2);
  
public native class Boolean { 
	private boolean value;
	public native Boolean(boolean value)/*-
	{
		this.value = value;
	} -*/;
	
	public native String toString() /*-{
		return this.value;
	}-*/;
	
	public Boolean valueOf(){
		return this.value;
	}
}

public class Byte extends Number{ 
	private byte value;
	public native Byte(byte value)/*-
	{
		this.value = value;
	} -*/;
	
	public native String toString() /*-{
		return this.value;
	}-*/;
	
	public Byte valueOf(){
		return this.value;
	}
}

public class Double extends Number{
	private double value;
	public native Double(double value)/*-
	{
		this.value = value;
	} -*/;
	
	public native String toString() /*-{
		return this.value;
	}-*/;
	
	public Double valueOf(){
		return this.value;
	}
}

public class Float extends Number{
	private float value;
	public native Float(float value)/*-
	{
		this.value = value;
	} -*/;
	
	public native String toString() /*-{
		return this.value;
	}-*/;
	
	public Float valueOf(){
		return this.value;
	}
}

public native final class Function {

	public native arguments arguments{};

	public native void apply(Object context);

	public native void apply(Object context, arguments argument);

	public native void call(Object context, Object... pars);

	public native Function bind(Object thisArg);

	public native Function bind(Object thisArg, Object... args);

}

public final native class Math {  
	private native Math();
	/**
	 * The mathematical constant e. This is Euler's number, the base of natural
	 * logarithms. 2.718
	 */
	public static native float E{} // = 2.718f;

	/**
	 * The natural logarithm of 2. 
	 */
	public static native float LN2{} // = 0.693f;
	/**
	 * 
	 */
	public static native float LN10{} // = 2.302f; 
	/**
	 * The base-2 logarithm of e.
	 */
	public static native float LOG2E{} // = 1.443f;
	/**
	 * The base-10 logarithm of e.
	 */
	public static native float LOG10E{} // = 0.434f;
	/**
	 * Pi. This is the ratio of the circumference of a circle to its diameter.
	 */
	public static native float PI{} // = 3.14159f;
	/**
	 * The square root of 0.5, or, equivalently, one divided by the square root
	 * of 2.
	 */
	public static native float SQRT1_2{} // = 0.707f;
	/**
	 * The square root of 2.
	 */
	public static final float SQRT2{} // = 1.414f;

	public static native int abs(int number);
	public static native long abs(long number);
	public static native float abs(float number);
	public static native double abs(double number);

	public static native double acos(double number);

	public static native double asin(double number);

	public static native double atan(double number);

	public static native double atan2(double x, Number y);

	public static native double ceil(double number);

	public static native double cos(double number);

	public static native double exp(double number);
 
	public static native double floor(double number);

	public static native double log(double number);

//	public static native double max(double... number);  
//	public static native float max(float... number);
//	public static native int max(int... number);
//	public static native long max(long... number); 
	public static native Number max(Number... number); 

//	public static native double min(double... number);
//	public static native float min(float... number); 
//	public static native int min(int... number);
//	public static native long min(long... number); 
	public static native Number min(Number... number); 

	public static native double pow(double base, double exponent);

	public static native double random();

	public static native int round(float number);
	public static native long round(double number);

	public static native double sin(double radians);

	public static native double sqrt(double number);

	public static native double tan(double radians); 

}


public native class Number {
	public native Number(Object value);
	
	/**
	 * The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308.
	 */
	public native static Number MAX_VALUE{}
	
	/**
	 * The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324.
	 */
	public native static Number MIN_VALUE{}
	
	/**
	 * 	A value that is not a number. In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.
	 */
	public native static Number NaN{}

	/**
	 * 	A value that is less than the largest negative number that can be represented in JavaScript. JavaScript displays NEGATIVE_INFINITY values as -infinity.
	 */
	public native static Number NEGATIVE_INFINITY{}
	
	/**
	 * A value greater than the largest number that can be represented in JavaScript. 	JavaScript displays POSITIVE_INFINITY values as infinity.
	 */
	public native static Number POSITIVE_INFINITY{}
	
	public native static Number EPSILON{}
	
	public native String toString(int radix);
	
	public native String toExponential();
	
	public native String toExponential(int fractionDigits);
	
	public native String toFixed();
	
	public native String toFixed(int fractionDigits);
	
	public native String toLocaleString();
	
	public native String toLocaleString(String[] locales);
	
	public native String toLocaleString(String[] locales, Object options);
	
	public native Number toPrecision();
	
	public native Number toPrecision(int precision);
	
	public native Number valueOf();
}


public native final class String {
	public native String(String literal); 

	public native int length{&;}
	
	public native static String fromCharCode(int ... charCode);
	/**
	 * Places an HTML anchor that has a NAME attribute around the text. The name
	 * parameter is text to put in the NAME attribute of the HTML anchor.
	 */
	public native String anchor(String name);

	/**
	 * Places HTML <BIG> tags around the text. Discouraged
	 */
	public native String big();

	/**
	 * Places HTML <BLINK> tags around the text. The <BLINK> tag is not
	 * supported in Internet Explorer. Not in standard
	 */
	public native String blink();

	/**
	 * Places HTML <B> tags around the text. Discouraged
	 */
	public native String bold();

	/**
	 * Places HTML <TT> tags around the text.
	Discouraged
	 */
	public native String fixed();

	/**
	 * Places HTML <FONT> tags with a COLOR attribute around the text. The color
	 * parameter is a string value that contains the hexadecimal value or
	 * predefined name for a color. Valid predefined color names depend on the
	 * JavaScript host browser and its version. Deprecated
	 */
	public native String fontcolor(String color);

	/**
	 * Places HTML <FONT> tags with a SIZE attribute around the text. The size
	 * parameter is an integer value that specifies the size of the text. Valid
	 * integer values depend on the JavaScript host browser and its version.
	 * Deprecated
	 */
	public native String fontsize(int size);

	/**
	 * Places HTML <I> tags around the text. Discouraged
	 */
	public native String italics();

	/**
	 * Places an HTML anchor that has an HREF attribute around the text. The
	 * href parameter is text to put in the HREF attribute of the HTML anchor.
	 */
	public native String link(String href);

	/**
	 * Places HTML <SMALL> tags around the text. Discouraged
	 */
	public native String small();

	/**
	 * Places HTML <STRIKE> tags around the text. Deprecated
	 */
	public native String strike();

	/**
	 * Places HTML <SUB> tags around the text.
	 */
	public native String sub();

	/**
	 * Places HTML <SUP> tags around the text.
	 */
	public native String sup();

	public native int charCodeAt(int index);

	public native String concat(String... strs);

	public native int indexOf(String subString);

	public native int indexOf(String subString, int startIndex);

	public native int lastIndexOf(String subString);

	public native int lastIndexOf(String subString, int startIndex);

	public native int localeCompare(String stringExp);

	public native int localeCompare(String stringExp, String[] locales);

	public native int localeCompare(String stringExp, String[] locales,
			Object options);

	public native String[] match(RegExp regexp);

	public native String replace(RegExp rgExp, String replaceText);

	public native String search(RegExp rgExp);

	public native String slice(int start);

	public native String slice(int start, int end);

	public native String charAt(int index);

	public native String[] split();

	public native String[] split(String separator);

	public native String[] split(String separator, int limit);

	public native String substr(int start);

	public native String substr(int start, int length);

	public native String substring(int start);

	public native String substring(int start, int end);

	public native String toLocaleLowerCase();

	public native String toLocaleUpperCase();

	public native String toLowerCase();

	public native String toUpperCase();

	public native String trim();

	public native String valueOf();
	
	public native String this[int index];
	
	public boolean isWhiteSpace() {
		String whitespaceChars = " \t\n\r\f";
		return (whitespaceChars.indexOf(this) != -1);
	}
	
  public static String Empty = "";
  public static boolean isNullOrEmpty(String str){
  	if(str == null || str == String.Empty){
  		return true;
  	}
  	return false;
  }
  
  public native char this[int index];

}


public native final class RegExp {
	public native RegExp(String pattern, String flag);
	
	public native final String index{&;}
	
	public native final String input{&;}
	
	public native final String lastIndex{&;}
	
	public native final String lastMatch{&;}
	
	public native final String lastParen{&;}
	
	public native final String leftContext{&;}
	
	public native final String rightContext{&;}
	
	public native final String $1{&;}
	
	public native final String $2{&;}
	
	public native final String $3{&;}
	
	public native final String $4{&;}
	
	public native final String $5{&;}
	
	public native final String $6{&;}
	
	public native final String $7{&;}
	
	public native final String $8{&;}
	
	public native final String $9{&;}
	
	public native void compile(String regexp, String modifier);
	
	public native String[] exec(String string);
	
	public native boolean test(String string);
}

public class Short extends Number{
	private short value;
	public native Short(short value)/*-
	{
		this.value = value;
	} -*/;
	
	public native String toString() /*-{
		return this.value;
	}-*/;
	
	public Short valueOf(){
		return this.value;
	}
}

public class Character { 
	private char value;
	public Character(char value)
	{
		this.value = value;
	} 
	
	public native String toString() /*-{
		return this.value;
	}-*/;
	
	public Object valueOf(){
		return this.value;
	}
}

public class Long extends Number{
	private long value;
	public native Long(long value)/*-
	{
		this.value = value;
	} -*/;
	
	public native String toString() /*-{
		return this.value;
	}-*/;
	
	public Long valueOf(){
		return this.value;
	}
}

public class Integer extends Number{
    /**
     * A constant holding the minimum value an {@code int} can
     * have, -2<sup>31</sup>.
     */
    public static final int MIN_VALUE = 0x80000000;

    /**
     * A constant holding the maximum value an {@code int} can
     * have, 2<sup>31</sup>-1.
     */
    public static final int MAX_VALUE = 0x7fffffff;
    
	private int value;
	public native Integer(int value)/*-
	{
		this.value = value;
	} -*/;
	
	public native String toString() /*-{
		return this.value;
	}-*/;
	
	public Integer valueOf(){
		return this.value;
	}
}


/**
 * The class {@code Exception} and its subclasses are a form of
 * {@code Throwable} that indicates conditions that a reasonable
 * application might want to catch.
 *
 * <p>The class {@code Exception} and any subclasses that are not also
 * subclasses of {@link RuntimeException} are <em>checked
 * exceptions</em>.  Checked exceptions need to be declared in a
 * method or constructor's {@code throws} clause if they can be thrown
 * by the execution of the method or constructor and propagate outside
 * the method or constructor boundary.
 *
 * @author  Frank Yellin
 * @see     java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */
public class Exception extends Throwable {
    private String _message;

    /**
     * Constructs a new exception with {@code null} as its detail message.
     * The cause is not initialized, and may subsequently be initialized by a
     * call to {@link #initCause}.
     */
    @Overload("1")
    public Exception() {
    }

    /**
     * Constructs a new exception with the specified detail message.  The
     * cause is not initialized, and may subsequently be initialized by
     * a call to {@link #initCause}.
     *
     * @param   message   the detail message. The detail message is saved for
     *          later retrieval by the {@link #getMessage()} method.
     */
    @Overload("2")
    public Exception(String message) {
        this._message = message;
    }

	public String getMessage() {
		return _message;
	}

	public String getLocalizedMessage() {
		return _message;
	}
}

/**
 * {@code RuntimeException} is the superclass of those
 * exceptions that can be thrown during the normal operation of the
 * Java Virtual Machine.
 *
 * <p>{@code RuntimeException} and its subclasses are <em>unchecked
 * exceptions</em>.  Unchecked exceptions do <em>not</em> need to be
 * declared in a method or constructor's {@code throws} clause if they
 * can be thrown by the execution of the method or constructor and
 * propagate outside the method or constructor boundary.
 *
 * @author  Frank Yellin
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */
public class RuntimeException extends Exception {

    /** Constructs a new runtime exception with {@code null} as its
     * detail message.  The cause is not initialized, and may subsequently be
     * initialized by a call to {@link #initCause}.
     */
    @Overload("1")
    public RuntimeException() {
        super();
    }

    /** Constructs a new runtime exception with the specified detail message.
     * The cause is not initialized, and may subsequently be initialized by a
     * call to {@link #initCause}.
     *
     * @param   message   the detail message. The detail message is saved for
     *          later retrieval by the {@link #getMessage()} method.
     */
    @Overload("2")
    public RuntimeException(String message) {
        super(message);
    }
}

/**
 * Thrown when an application attempts to use {@code null} in a
 * case where an object is required. These include:
 * <ul>
 * <li>Calling the instance method of a {@code null} object.
 * <li>Accessing or modifying the field of a {@code null} object.
 * <li>Taking the length of {@code null} as if it were an array.
 * <li>Accessing or modifying the slots of {@code null} as if it
 *     were an array.
 * <li>Throwing {@code null} as if it were a {@code Throwable}
 *     value.
 * </ul>
 * <p>
 * Applications should throw instances of this class to indicate
 * other illegal uses of the {@code null} object.
 *
 * {@code NullPointerException} objects may be constructed by the 
 * virtual machine as if {@linkplain Throwable#Throwable(String,
 * Throwable, boolean, boolean) suppression were disabled and/or the
 * stack trace was not writable}.
 *
 * @author  unascribed
 * @since   JDK1.0
 */
public class NullPointerException extends RuntimeException {
    private static final long serialVersionUID = 5162710183389028792L;

    /**
     * Constructs a {@code NullPointerException} with no detail message.
     */
    public NullPointerException() {
        super();
    }

    /**
     * Constructs a {@code NullPointerException} with the specified
     * detail message.
     *
     * @param   s   the detail message.
     */
    public NullPointerException(String s) {
        super(s);
    }
}

/**
 * Thrown when an application tries to load in a class through its
 * string name using:
 * <ul>
 * <li>The <code>forName</code> method in class <code>Class</code>.
 * <li>The <code>findSystemClass</code> method in class
 *     <code>ClassLoader</code> .
 * <li>The <code>loadClass</code> method in class <code>ClassLoader</code>.
 * </ul>
 * <p>
 * but no definition for the class with the specified name could be found.
 *
 * <p>As of release 1.4, this exception has been retrofitted to conform to
 * the general purpose exception-chaining mechanism.  The "optional exception
 * that was raised while loading the class" that may be provided at
 * construction time and accessed via the {@link #getException()} method is
 * now known as the <i>cause</i>, and may be accessed via the {@link
 * Throwable#getCause()} method, as well as the aforementioned "legacy method."
 *
 * @author  unascribed
 * @see     java.lang.Class#forName(java.lang.String)
 * @see     java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see     java.lang.ClassLoader#loadClass(java.lang.String, boolean)
 * @since   JDK1.0
 */
public class ClassNotFoundException extends RuntimeException {
    /**
     * use serialVersionUID from JDK 1.1.X for interoperability
     */
     private static final long serialVersionUID = 9176873029745254542L;

    /**
     * Constructs a <code>ClassNotFoundException</code> with no detail message.
     */
    public ClassNotFoundException() {
        
    }

    /**
     * Constructs a <code>ClassNotFoundException</code> with the
     * specified detail message.
     *
     * @param   s   the detail message.
     */
    public ClassNotFoundException(String s) {
        super(s);  
    }
}

/**
 * Thrown to indicate that the <code>clone</code> method in class
 * <code>Object</code> has been called to clone an object, but that
 * the object's class does not implement the <code>Cloneable</code>
 * interface.
 * <p>
 * Applications that override the <code>clone</code> method can also
 * throw this exception to indicate that an object could not or
 * should not be cloned.
 *
 * @author  unascribed
 * @see     java.lang.Cloneable
 * @see     java.lang.Object#clone()
 * @since   JDK1.0
 */

public class CloneNotSupportedException extends Exception {
    private static final long serialVersionUID = 5195511250079656443L;

    /**
     * Constructs a <code>CloneNotSupportedException</code> with no
     * detail message.
     */
    public CloneNotSupportedException() {
        super();
    }

    /**
     * Constructs a <code>CloneNotSupportedException</code> with the
     * specified detail message.
     *
     * @param   s   the detail message.
     */
    public CloneNotSupportedException(String s) {
        super(s);
    }
}

public native class arguments {
	public native final int length{};
}

public native class Set<T> {
	public native int size{}
	/**
	 * 	Adds an element to a set.
	 */
	public native void add(T element);

	/**
	 * 	Removes all elements from a set.
	 */
	public native void clear();

	/**
	 * 	Removes a specified element from a set.
	 */
	public native boolean delete(T element);

	/**
	 * 	Performs the specified action for each element in a set.
	 */
	public native void forEach(SetCallback<T> callback);
	public native void forEach(SetCallback<T> callback, Object thisContext);

	/**
	 * 	Returns true if the set contains a specified element.
	 */
	public native boolean has(T element);

}

public native class Map<K, V> {
	public native int size{}
	/**
	 * 	Adds an element to a set.
	 */
	public native void set(K key, V element);

	/**
	 * 	Removes all elements from a set.
	 */
	public native void clear();

	/**
	 * 	Removes a specified element from a set.
	 */
	public native boolean delete(K key);

	/**
	 * 	Performs the specified action for each element in a set.
	 */
	public native void forEach(MapCallback<K, V> callback);
	public native void forEach(MapCallback<K, V> callback, Object thisContext);
	
	public native V get(K key);

	/**
	 * 	Returns true if the set contains a specified element.
	 */
	public native boolean has(K key);

}

public function void MapCallback<K, V>(V value, K key, Map<K, V> mapObj);

public function void SetCallback<T>(T value, int index, Array<T> array1); 

/**
 * 
 * @author cym
 * 
 */
public abstract class Template {
	public final Node create(Node parent){
		return doCreate(parent);
	}
	
	protected Node doCreate(Node parent){
		throw new Error(0, "illegal call!");
	}
}

public abstract class ItemTemplate {
	public final Node create(Node parent, Object item){
		Node root = createRoot(parent, item);
//		root.dataContext = new DataContext(item);
		createChild(root);
		return root;
	}
	
	public Node createChild(Node parent){
		throw new Error(0, "illegal call!");
	}
	
	public Node createRoot(Node parent, Object item){
		throw new Error(0, "illegal call!");
	}
}

/**
 * 
 * @author cym
 *
 */
public abstract class Component {
	public void create(HTMLElement parent){
		doCreate(parent);
	}
	
	protected void doCreate(HTMLElement parent){
		throw new Error(0, "illegal call!");
	}
}

/**
 * Implementing this interface allows an object to be the target of
 * the "for-each loop" statement. See
 * <strong>
 * <a href="{@docRoot}/../technotes/guides/language/foreach.html">For-each Loop</a>
 * </strong>
 *
 * @param <T> the type of elements returned by the iterator
 *
 * @since 1.5
 * @jls 14.14.2 The enhanced for statement
 */
public interface Iterable<T> {
    /**
     * Returns an iterator over elements of type {@code T}.
     *
     * @return an Iterator.
     */
    Iterator<T> iterator(); 

    /**
     * Performs the given action on the contents of the {@code Iterable}, in the
     * order elements occur when iterating, until all elements have been
     * processed or the action throws an exception.  Errors or runtime
     * exceptions thrown by the action are relayed to the caller.
     *
     * @implSpec
     * <p>The default implementation behaves as if:
     * <pre>{@code
     *     for (T t : this)
     *         action.accept(t);
     * }</pre>
     *
     * @param action The action to be performed for each element
     * @throws NullPointerException if the specified action is null
     * @since 1.8
     */
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action(t);
        }
    }
}

public function R Operator<T, R> (T t);

public function T UnaryOperator<T> (T t);

public function void Consumer<T>(T t);

/**
 * This is the common base class of all Java language enumeration types.
 *
 * @author  Josh Bloch
 * @author  Neal Gafter
 * @version %I%, %G%
 * @since   1.5
 */ 
public abstract class Enum<E extends Enum<E>>
        implements Comparable<E> { 
	/**
     * The name of this enum constant, as declared in the enum declaration.
     * Most programmers should use the {@link #toString} method rather than
     * accessing this field.
     */ 
    private final String _name; 
 
    /**
     * Returns the name of this enum constant, exactly as declared in its
     * enum declaration.
     * 
     * <b>Most programmers should use the {@link #toString} method in
     * preference to this one, as the toString method may return
     * a more user-friendly name.</b>  This method is designed primarily for
     * use in specialized situations where correctness depends on getting the
     * exact name, which will not vary from release to release.
     *
     * @return the name of this enum constant
     */ 
    public final String name { 
    	&{return _name;}
    } 
 
    /**
     * The ordinal of this enumeration constant (its position
     * in the enum declaration, where the initial constant is assigned
     * an ordinal of zero).
     * 
     * Most programmers will have no use for this field.  It is designed
     * for use by sophisticated enum-based data structures, such as
     * {@link java.util.EnumSet} and {@link java.util.EnumMap}.
     */ 
    private final int _ordinal; 
 
    /**
     * Returns the ordinal of this enumeration constant (its position
     * in its enum declaration, where the initial constant is assigned
     * an ordinal of zero).
     * 
     * Most programmers will have no use for this method.  It is
     * designed for use by sophisticated enum-based data structures, such
     * as {@link java.util.EnumSet} and {@link java.util.EnumMap}.
     *
     * @return the ordinal of this enumeration constant
     */ 
    public final int ordinal { 
    	&{return _ordinal; }
    } 
 
    /**
     * Sole constructor.  Programmers cannot invoke this constructor.
     * It is for use by code emitted by the compiler in response to
     * enum type declarations.
     *
     * @param name - The name of this enum constant, which is the identifier
     *               used to declare it.
     * @param ordinal - The ordinal of this enumeration constant (its position
     *         in the enum declaration, where the initial constant is assigned
     *         an ordinal of zero).
     */ 
    protected Enum(String name, int ordinal) { 
	    this._name = name; 
	    this._ordinal = ordinal; 
    } 
 
    /**
     * Returns the name of this enum constant, as contained in the
     * declaration.  This method may be overridden, though it typically
     * isn't necessary or desirable.  An enum type should override this
     * method when a more "programmer-friendly" string form exists.
     *
     * @return the name of this enum constant
     */ 
    public String toString() { 
    	return name; 
    } 
 
    /**
     * Returns true if the specified object is equal to this
     * enum constant.
     *
     * @param other the object to be compared for equality with this object.
     * @return  true if the specified object is equal to this
     *          enum constant.
     */ 
    public final boolean equals(Object other) {  
        return this===other; 
    } 
 
    /**
     * Returns a hash code for this enum constant.
     *
     * @return a hash code for this enum constant.
     */ 
    public final int hashCode() { 
        return super.hashCode(); 
    } 
 
    /**
     * Throws CloneNotSupportedException.  This guarantees that enums
     * are never cloned, which is necessary to preserve their "singleton"
     * status.
     *
     * @return (never returns)
     */ 
    protected final Object clone() throws CloneNotSupportedException { 
    throw new CloneNotSupportedException(); 
    } 
 
    /**
     * Compares this enum with the specified object for order.  Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     * 
     * Enum constants are only comparable to other enum constants of the
     * same enum type.  The natural order implemented by this
     * method is the order in which the constants are declared.
     */ 
    public final int compareTo(E o) { 
	    Enum other = (Enum)o; 
	    Enum self = this; 
	    if (self.getClass() != other.getClass() && // optimization 
	            self.getDeclaringClass() != other.getDeclaringClass()) 
	        throw new Error(); 
	    return self.ordinal - other.ordinal; 
    } 
 
    /**
     * Returns the Class object corresponding to this enum constant's
     * enum type.  Two enum constants e1 and  e2 are of the
     * same enum type if and only if
     *   e1.getDeclaringClass() == e2.getDeclaringClass().
     * (The value returned by this method may differ from the one returned
     * by the {@link Object#getClass} method for enum constants with
     * constant-specific class bodies.)
     *
     * @return the Class object corresponding to this enum constant's
     *     enum type
     */ 
    public final Class<E> getDeclaringClass() { 
	    Class clazz = getClass(); 
	    Class zuper = clazz.superClass; 
	    return (zuper == Enum.class) ? clazz : zuper; 
    } 
} 

/**
 * Thrown to indicate that a method has been passed an illegal or
 * inappropriate argument.
 *
 * @author  unascribed
 * @since   JDK1.0
 */
public
class IllegalArgumentException extends RuntimeException {
    /**
     * Constructs an <code>IllegalArgumentException</code> with no
     * detail message.
     */
    public IllegalArgumentException() {
        super();
    }

    /**
     * Constructs an <code>IllegalArgumentException</code> with the
     * specified detail message.
     *
     * @param   s   the detail message.
     */
    public IllegalArgumentException(String s) {
        super(s);
    }
}

/**
 * Signals that a method has been invoked at an illegal or
 * inappropriate time.  In other words, the Java environment or
 * Java application is not in an appropriate state for the requested
 * operation.
 *
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */
public class IllegalStateException extends RuntimeException {
    /**
     * Constructs an IllegalStateException with no detail message.
     * A detail message is a String that describes this particular exception.
     */
    public IllegalStateException() {
        super();
    }

    /**
     * Constructs an IllegalStateException with the specified detail
     * message.  A detail message is a String that describes this particular
     * exception.
     *
     * @param s the String that contains a detailed message
     */
    public IllegalStateException(String s) {
        super(s);
    }
}

/**
 * Thrown to indicate that the requested operation is not supported.<p>
 *
 * This class is a member of the
 * <a href="{@docRoot}/../technotes/guides/collections/index.html">
 * Java Collections Framework</a>.
 *
 * @author  Josh Bloch
 * @since   1.2
 */
public class UnsupportedOperationException extends RuntimeException {
    /**
     * Constructs an UnsupportedOperationException with no detail message.
     */
    public UnsupportedOperationException() {
    }

    /**
     * Constructs an UnsupportedOperationException with the specified
     * detail message.
     *
     * @param message the detail message
     */
    public UnsupportedOperationException(String message) {
        super(message);
    }
}

/**
 * This interface imposes a total ordering on the objects of each class that
 * implements it.  This ordering is referred to as the class's <i>natural
 * ordering</i>, and the class's <tt>compareTo</tt> method is referred to as
 * its <i>natural comparison method</i>.<p>
 *
 * Lists (and arrays) of objects that implement this interface can be sorted
 * automatically by {@link Collections#sort(List) Collections.sort} (and
 * {@link Arrays#sort(Object[]) Arrays.sort}).  Objects that implement this
 * interface can be used as keys in a {@linkplain SortedMap sorted map} or as
 * elements in a {@linkplain SortedSet sorted set}, without the need to
 * specify a {@linkplain Comparator comparator}.<p>
 *
 * The natural ordering for a class <tt>C</tt> is said to be <i>consistent
 * with equals</i> if and only if <tt>e1.compareTo(e2) == 0</tt> has
 * the same boolean value as <tt>e1.equals(e2)</tt> for every
 * <tt>e1</tt> and <tt>e2</tt> of class <tt>C</tt>.  Note that <tt>null</tt>
 * is not an instance of any class, and <tt>e.compareTo(null)</tt> should
 * throw a <tt>NullPointerException</tt> even though <tt>e.equals(null)</tt>
 * returns <tt>false</tt>.<p>
 *
 * It is strongly recommended (though not required) that natural orderings be
 * consistent with equals.  This is so because sorted sets (and sorted maps)
 * without explicit comparators behave "strangely" when they are used with
 * elements (or keys) whose natural ordering is inconsistent with equals.  In
 * particular, such a sorted set (or sorted map) violates the general contract
 * for set (or map), which is defined in terms of the <tt>equals</tt>
 * method.<p>
 *
 * For example, if one adds two keys <tt>a</tt> and <tt>b</tt> such that
 * <tt>(!a.equals(b) && a.compareTo(b) == 0)</tt> to a sorted
 * set that does not use an explicit comparator, the second <tt>add</tt>
 * operation returns false (and the size of the sorted set does not increase)
 * because <tt>a</tt> and <tt>b</tt> are equivalent from the sorted set's
 * perspective.<p>
 *
 * Virtually all Java core classes that implement <tt>Comparable</tt> have natural
 * orderings that are consistent with equals.  One exception is
 * <tt>java.math.BigDecimal</tt>, whose natural ordering equates
 * <tt>BigDecimal</tt> objects with equal values and different precisions
 * (such as 4.0 and 4.00).<p>
 *
 * For the mathematically inclined, the <i>relation</i> that defines
 * the natural ordering on a given class C is:<pre>
 *       {(x, y) such that x.compareTo(y) &lt;= 0}.
 * </pre> The <i>quotient</i> for this total order is: <pre>
 *       {(x, y) such that x.compareTo(y) == 0}.
 * </pre>
 *
 * It follows immediately from the contract for <tt>compareTo</tt> that the
 * quotient is an <i>equivalence relation</i> on <tt>C</tt>, and that the
 * natural ordering is a <i>total order</i> on <tt>C</tt>.  When we say that a
 * class's natural ordering is <i>consistent with equals</i>, we mean that the
 * quotient for the natural ordering is the equivalence relation defined by
 * the class's {@link Object#equals(Object) equals(Object)} method:<pre>
 *     {(x, y) such that x.equals(y)}. </pre><p>
 *
 * This interface is a member of the
 * <a href="{@docRoot}/../technotes/guides/collections/index.html">
 * Java Collections Framework</a>.
 *
 * @param <T> the type of objects that this object may be compared to
 *
 * @author  Josh Bloch
 * @see java.util.Comparator
 * @since 1.2
 */
@FunctionalInterface
public interface Comparable<T> {
    /**
     * Compares this object with the specified object for order.  Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     *
     * <p>The implementor must ensure <tt>sgn(x.compareTo(y)) ==
     * -sgn(y.compareTo(x))</tt> for all <tt>x</tt> and <tt>y</tt>.  (This
     * implies that <tt>x.compareTo(y)</tt> must throw an exception iff
     * <tt>y.compareTo(x)</tt> throws an exception.)
     *
     * <p>The implementor must also ensure that the relation is transitive:
     * <tt>(x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0)</tt> implies
     * <tt>x.compareTo(z)&gt;0</tt>.
     *
     * <p>Finally, the implementor must ensure that <tt>x.compareTo(y)==0</tt>
     * implies that <tt>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</tt>, for
     * all <tt>z</tt>.
     *
     * <p>It is strongly recommended, but <i>not</i> strictly required that
     * <tt>(x.compareTo(y)==0) == (x.equals(y))</tt>.  Generally speaking, any
     * class that implements the <tt>Comparable</tt> interface and violates
     * this condition should clearly indicate this fact.  The recommended
     * language is "Note: this class has a natural ordering that is
     * inconsistent with equals."
     *
     * <p>In the foregoing description, the notation
     * <tt>sgn(</tt><i>expression</i><tt>)</tt> designates the mathematical
     * <i>signum</i> function, which is defined to return one of <tt>-1</tt>,
     * <tt>0</tt>, or <tt>1</tt> according to whether the value of
     * <i>expression</i> is negative, zero or positive.
     *
     * @param   o the object to be compared.
     * @return  a negative integer, zero, or a positive integer as this object
     *          is less than, equal to, or greater than the specified object.
     *
     * @throws NullPointerException if the specified object is null
     * @throws ClassCastException if the specified object's type prevents it
     *         from being compared to this object.
     */
    public int compareTo(T o);
}

/**
 * A class implements the <code>Cloneable</code> interface to
 * indicate to the {@link java.lang.Object#clone()} method that it
 * is legal for that method to make a
 * field-for-field copy of instances of that class.
 * <p>
 * Invoking Object's clone method on an instance that does not implement the
 * <code>Cloneable</code> interface results in the exception
 * <code>CloneNotSupportedException</code> being thrown.
 * <p>
 * By convention, classes that implement this interface should override
 * <tt>Object.clone</tt> (which is protected) with a public method.
 * See {@link java.lang.Object#clone()} for details on overriding this
 * method.
 * <p>
 * Note that this interface does <i>not</i> contain the <tt>clone</tt> method.
 * Therefore, it is not possible to clone an object merely by virtue of the
 * fact that it implements this interface.  Even if the clone method is invoked
 * reflectively, there is no guarantee that it will succeed.
 *
 * @author  unascribed
 * @see     java.lang.CloneNotSupportedException
 * @see     java.lang.Object#clone()
 * @since   JDK1.0
 */
public interface Cloneable {
}

public class JSON {
	public native static Object parse(String text);

	public native static Object parse(String text, Function reviver);

	public native static String stringify(Object value);

	public native static String stringify(Object value, Function replacer);

	public native static String stringify(Object value, Function replacer,
			String space);

	public native static String stringify(Object value, Array<String> replacer);

	public native static String stringify(Object value, Array<String> replacer,
			String space);

}
