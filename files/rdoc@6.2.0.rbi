# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca generate

# typed: true

module RDoc
  def self.load_yaml; end
end

RDoc::ATTR_MODIFIERS = T.let(T.unsafe(nil), Array)

class RDoc::Alias < ::RDoc::CodeObject
  def initialize(text, old_name, new_name, comment, singleton = _); end

  def <=>(other); end
  def aref; end
  def full_old_name; end
  def html_name; end
  def inspect; end
  def name; end
  def name_prefix; end
  def new_name; end
  def old_name; end
  def pretty_name; end
  def pretty_new_name; end
  def pretty_old_name; end
  def singleton; end
  def singleton=(_); end
  def text; end
  def to_s; end
end

class RDoc::AnonClass < ::RDoc::ClassModule
end

class RDoc::AnyMethod < ::RDoc::MethodAttr
  include(::RDoc::TokenStream)

  def initialize(text, name); end

  def add_alias(an_alias, context = _); end
  def aref_prefix; end
  def arglists; end
  def c_function; end
  def c_function=(_); end
  def call_seq; end
  def call_seq=(call_seq); end
  def calls_super; end
  def calls_super=(_); end
  def dont_rename_initialize; end
  def dont_rename_initialize=(_); end
  def is_alias_for; end
  def marshal_dump; end
  def marshal_load(array); end
  def name; end
  def param_list; end
  def param_seq; end
  def params; end
  def params=(_); end
  def store=(store); end
  def superclass_method; end
end

RDoc::AnyMethod::MARSHAL_VERSION = T.let(T.unsafe(nil), Integer)

class RDoc::Attr < ::RDoc::MethodAttr
  def initialize(text, name, rw, comment, singleton = _); end

  def ==(other); end
  def add_alias(an_alias, context); end
  def aref_prefix; end
  def calls_super; end
  def definition; end
  def inspect; end
  def marshal_dump; end
  def marshal_load(array); end
  def pretty_print(q); end
  def rw; end
  def rw=(_); end
  def to_s; end
  def token_stream; end
end

RDoc::Attr::MARSHAL_VERSION = T.let(T.unsafe(nil), Integer)

RDoc::CLASS_MODIFIERS = T.let(T.unsafe(nil), Array)

RDoc::CONSTANT_MODIFIERS = T.let(T.unsafe(nil), Array)

class RDoc::ClassModule < ::RDoc::Context
  def initialize(name, superclass = _); end

  def add_comment(comment, location); end
  def add_things(my_things, other_things); end
  def ancestors; end
  def aref; end
  def aref_prefix; end
  def clear_comment; end
  def comment=(comment); end
  def comment_location; end
  def comment_location=(_); end
  def complete(min_visibility); end
  def constant_aliases; end
  def constant_aliases=(_); end
  def description; end
  def diagram; end
  def diagram=(_); end
  def direct_ancestors; end
  def document_self_or_methods; end
  def documented?; end
  def each_ancestor; end
  def find_ancestor_local_symbol(symbol); end
  def find_class_named(name); end
  def full_name; end
  def is_alias_for; end
  def is_alias_for=(_); end
  def marshal_dump; end
  def marshal_load(array); end
  def merge(class_module); end
  def merge_collections(mine, other, other_files, &block); end
  def merge_sections(cm); end
  def module?; end
  def name=(new_name); end
  def name_for_path; end
  def non_aliases; end
  def parse(comment_location); end
  def path; end
  def remove_nodoc_children; end
  def remove_things(my_things, other_files); end
  def search_record; end
  def store=(store); end
  def superclass; end
  def superclass=(superclass); end
  def to_s; end
  def type; end
  def update_aliases; end
  def update_extends; end
  def update_includes; end
  def with_documentation?; end

  def self.from_module(class_type, mod); end
end

RDoc::ClassModule::MARSHAL_VERSION = T.let(T.unsafe(nil), Integer)

class RDoc::CodeObject
  include(::RDoc::Generator::Markup)
  include(::RDoc::Text)

  def initialize; end

  def comment; end
  def comment=(comment); end
  def display?; end
  def document_children; end
  def document_children=(document_children); end
  def document_self; end
  def document_self=(document_self); end
  def documented?; end
  def done_documenting; end
  def done_documenting=(value); end
  def each_parent; end
  def file; end
  def file_name; end
  def force_documentation; end
  def force_documentation=(value); end
  def full_name=(full_name); end
  def ignore; end
  def ignored?; end
  def initialize_visibility; end
  def line; end
  def line=(_); end
  def metadata; end
  def options; end
  def parent; end
  def parent=(_); end
  def parent_file_name; end
  def parent_name; end
  def received_nodoc; end
  def record_location(top_level); end
  def section; end
  def section=(_); end
  def start_doc; end
  def stop_doc; end
  def store; end
  def store=(store); end
  def suppress; end
  def suppressed?; end
  def viewer; end
  def viewer=(_); end
end

class RDoc::Comment
  include(::RDoc::Text)

  def initialize(text = _, location = _, language = _); end

  def ==(other); end
  def document=(_); end
  def empty?; end
  def encode!(encoding); end
  def extract_call_seq(method); end
  def file; end
  def format; end
  def format=(format); end
  def inspect; end
  def location; end
  def location=(_); end
  def normalize; end
  def normalized?; end
  def parse; end
  def remove_private; end
  def text; end
  def text=(text); end
  def to_s; end
  def tomdoc?; end

  private

  def initialize_copy(copy); end
end

class RDoc::Constant < ::RDoc::CodeObject
  def initialize(name, value, comment); end

  def <=>(other); end
  def ==(other); end
  def documented?; end
  def full_name; end
  def inspect; end
  def is_alias_for; end
  def is_alias_for=(_); end
  def marshal_dump; end
  def marshal_load(array); end
  def name; end
  def name=(_); end
  def path; end
  def pretty_print(q); end
  def store=(store); end
  def to_s; end
  def value; end
  def value=(_); end
  def visibility; end
  def visibility=(_); end
end

RDoc::Constant::MARSHAL_VERSION = T.let(T.unsafe(nil), Integer)

class RDoc::Context < ::RDoc::CodeObject
  include(::Comparable)

  def initialize; end

  def <=>(other); end
  def add(klass, name, comment); end
  def add_alias(an_alias); end
  def add_attribute(attribute); end
  def add_class(class_type, given_name, superclass = _); end
  def add_class_or_module(mod, self_hash, all_hash); end
  def add_constant(constant); end
  def add_extend(ext); end
  def add_include(include); end
  def add_method(method); end
  def add_module(class_type, name); end
  def add_module_alias(from, from_name, to, file); end
  def add_module_by_normal_module(mod); end
  def add_require(require); end
  def add_section(title, comment = _); end
  def add_to(array, thing); end
  def aliases; end
  def any_content(includes = _); end
  def attributes; end
  def block_params; end
  def block_params=(_); end
  def child_name(name); end
  def class_attributes; end
  def class_method_list; end
  def classes; end
  def classes_and_modules; end
  def classes_hash; end
  def constants; end
  def constants_hash; end
  def current_line_visibility=(_); end
  def current_section; end
  def current_section=(_); end
  def defined_in?(file); end
  def display(method_attr); end
  def each_ancestor; end
  def each_attribute; end
  def each_classmodule(&block); end
  def each_constant; end
  def each_extend; end
  def each_include; end
  def each_method; end
  def each_section; end
  def extends; end
  def external_aliases; end
  def find_attribute(name, singleton); end
  def find_attribute_named(name); end
  def find_class_method_named(name); end
  def find_constant_named(name); end
  def find_enclosing_module_named(name); end
  def find_external_alias(name, singleton); end
  def find_external_alias_named(name); end
  def find_file_named(name); end
  def find_instance_method_named(name); end
  def find_local_symbol(symbol); end
  def find_method(name, singleton); end
  def find_method_named(name); end
  def find_module_named(name); end
  def find_symbol(symbol); end
  def find_symbol_module(symbol); end
  def full_name; end
  def fully_documented?; end
  def http_url(prefix); end
  def in_files; end
  def includes; end
  def initialize_methods_etc; end
  def instance_attributes; end
  def instance_method_list; end
  def method_list; end
  def methods_by_type(section = _); end
  def methods_hash; end
  def methods_matching(methods, singleton = _, &block); end
  def modules; end
  def modules_hash; end
  def name; end
  def name_for_path; end
  def ongoing_visibility=(visibility); end
  def params; end
  def params=(_); end
  def record_location(top_level); end
  def remove_from_documentation?; end
  def remove_invisible(min_visibility); end
  def remove_invisible_in(array, min_visibility); end
  def requires; end
  def resolve_aliases(added); end
  def section_contents; end
  def sections; end
  def sections_hash; end
  def set_constant_visibility_for(names, visibility); end
  def set_current_section(title, comment); end
  def set_visibility_for(methods, visibility, singleton = _); end
  def sort_sections; end
  def temporary_section; end
  def temporary_section=(_); end
  def to_s; end
  def top_level; end
  def unmatched_alias_lists; end
  def unmatched_alias_lists=(_); end
  def upgrade_to_class(mod, class_type, enclosing); end
  def visibility; end
  def visibility=(_); end
end

class RDoc::Context::Section
  include(::RDoc::Generator::Markup)
  include(::RDoc::Text)

  def initialize(parent, title, comment); end

  def ==(other); end
  def add_comment(comment); end
  def aref; end
  def comment; end
  def comments; end
  def eql?(other); end
  def extract_comment(comment); end
  def hash; end
  def in_files; end
  def inspect; end
  def marshal_dump; end
  def marshal_load(array); end
  def parent; end
  def parse; end
  def plain_html; end
  def remove_comment(comment); end
  def sequence; end
  def title; end
end

RDoc::Context::Section::MARSHAL_VERSION = T.let(T.unsafe(nil), Integer)

RDoc::Context::TOMDOC_TITLES = T.let(T.unsafe(nil), Array)

RDoc::Context::TOMDOC_TITLES_SORT = T.let(T.unsafe(nil), Array)

RDoc::Context::TYPES = T.let(T.unsafe(nil), Array)

class RDoc::CrossReference
  def initialize(context); end

  def resolve(name, text); end
  def seen; end
  def seen=(_); end
end

RDoc::CrossReference::ALL_CROSSREF_REGEXP = T.let(T.unsafe(nil), Regexp)

RDoc::CrossReference::CLASS_REGEXP_STR = T.let(T.unsafe(nil), String)

RDoc::CrossReference::CROSSREF_REGEXP = T.let(T.unsafe(nil), Regexp)

RDoc::CrossReference::METHOD_REGEXP_STR = T.let(T.unsafe(nil), String)

RDoc::DOT_DOC_FILENAME = T.let(T.unsafe(nil), String)

class RDoc::ERBIO < ::ERB
  def initialize(str, safe_level = _, trim_mode = _, eoutvar = _); end

  def set_eoutvar(compiler, io_variable); end
end

class RDoc::ERBPartial < ::ERB
  def set_eoutvar(compiler, eoutvar = _); end
end

module RDoc::Encoding
  def self.change_encoding(text, encoding); end
  def self.detect_encoding(string); end
  def self.read_file(filename, encoding, force_transcode = _); end
  def self.remove_frozen_string_literal(string); end
  def self.remove_magic_comment(string); end
end

RDoc::Encoding::HEADER_REGEXP = T.let(T.unsafe(nil), Regexp)

class RDoc::Error < ::RuntimeError
end

class RDoc::Extend < ::RDoc::Mixin
end

RDoc::GENERAL_MODIFIERS = T.let(T.unsafe(nil), Array)

module RDoc::Generator
end

class RDoc::Generator::Darkfish
  include(::ERB::Util)

  def initialize(store, options); end

  def assemble_template(body_file); end
  def asset_rel_path; end
  def asset_rel_path=(_); end
  def base_dir; end
  def class_dir; end
  def classes; end
  def copy_static; end
  def debug_msg(*msg); end
  def dry_run; end
  def dry_run=(_); end
  def file_dir; end
  def file_output; end
  def file_output=(_); end
  def files; end
  def gen_sub_directories; end
  def generate; end
  def generate_class(klass, template_file = _); end
  def generate_class_files; end
  def generate_file_files; end
  def generate_index; end
  def generate_page(file); end
  def generate_servlet_not_found(message); end
  def generate_servlet_root(installed); end
  def generate_table_of_contents; end
  def get_sorted_module_list(classes); end
  def get_svninfo(klass); end
  def install_rdoc_static_file(source, destination, options); end
  def json_index; end
  def methods; end
  def modsort; end
  def outputdir; end
  def render(file_name); end
  def render_template(template_file, out_file = _); end
  def setup; end
  def store; end
  def template_dir; end
  def template_for(file, page = _, klass = _); end
  def template_result(template, context, template_file); end
  def time_delta_string(seconds); end
  def write_style_sheet; end
end

RDoc::Generator::Darkfish::BUILTIN_STYLE_ITEMS = T.let(T.unsafe(nil), Array)

RDoc::Generator::Darkfish::DESCRIPTION = T.let(T.unsafe(nil), String)

RDoc::Generator::Darkfish::GENERATOR_DIR = T.let(T.unsafe(nil), String)

RDoc::Generator::Darkfish::SVNID_PATTERN = T.let(T.unsafe(nil), Regexp)

RDoc::Generator::Darkfish::VERSION = T.let(T.unsafe(nil), String)

class RDoc::Generator::JsonIndex
  include(::RDoc::Text)

  def initialize(parent_generator, options); end

  def build_index; end
  def class_dir; end
  def debug_msg(*msg); end
  def file_dir; end
  def generate; end
  def generate_gzipped; end
  def index; end
  def index_classes; end
  def index_methods; end
  def index_pages; end
  def reset(files, classes); end
  def search_string(string); end
end

RDoc::Generator::JsonIndex::SEARCH_INDEX_FILE = T.let(T.unsafe(nil), String)

module RDoc::Generator::Markup
  def aref_to(target_path); end
  def as_href(from_path); end
  def cvs_url(url, full_path); end
  def description; end
  def formatter; end
end

class RDoc::Generator::POT
  def initialize(store, options); end

  def class_dir; end
  def generate; end

  private

  def extract_messages; end
end

RDoc::Generator::POT::DESCRIPTION = T.let(T.unsafe(nil), String)

class RDoc::Generator::POT::MessageExtractor
  def initialize(store); end

  def extract; end

  private

  def entry(msgid, options); end
  def extract_from_klass(klass); end
  def extract_text(text, comment, location = _); end
end

class RDoc::Generator::POT::PO
  def initialize; end

  def add(entry); end
  def to_s; end

  private

  def add_header; end
  def header_entry; end
  def sort_entries; end
end

class RDoc::Generator::POT::POEntry
  def initialize(msgid, options = _); end

  def extracted_comment; end
  def flags; end
  def merge(other_entry); end
  def msgid; end
  def msgstr; end
  def references; end
  def to_s; end
  def translator_comment; end

  private

  def escape(string); end
  def format_comment(mark, comment); end
  def format_extracted_comment; end
  def format_flags; end
  def format_message(message); end
  def format_references; end
  def format_translator_comment; end
  def merge_array(array1, array2); end
  def merge_string(string1, string2); end
end

class RDoc::Generator::RI
  def initialize(store, options); end

  def generate; end
end

RDoc::Generator::RI::DESCRIPTION = T.let(T.unsafe(nil), String)

class RDoc::GhostMethod < ::RDoc::AnyMethod
end

module RDoc::I18n
end

class RDoc::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end
  def name; end
  def translate(message); end

  def self.[](locale_name); end
  def self.[]=(locale_name, locale); end
end

class RDoc::I18n::Text
  def initialize(raw); end

  def extract_messages; end
  def translate(locale); end

  private

  def each_line(raw, &block); end
  def emit_empty_line_event(line, line_no); end
  def emit_paragraph_event(paragraph, paragraph_start_line, line_no, &block); end
  def parse(&block); end
end

class RDoc::Include < ::RDoc::Mixin
end

RDoc::KNOWN_CLASSES = T.let(T.unsafe(nil), Hash)

RDoc::METHOD_MODIFIERS = T.let(T.unsafe(nil), Array)

class RDoc::Markdown
  def initialize(extensions = _, debug = _); end

  def _Alphanumeric; end
  def _AlphanumericAscii; end
  def _AtxHeading; end
  def _AtxInline; end
  def _AtxStart; end
  def _AutoLink; end
  def _AutoLinkEmail; end
  def _AutoLinkUrl; end
  def _BOM; end
  def _BlankLine; end
  def _Block; end
  def _BlockQuote; end
  def _BlockQuoteRaw; end
  def _Bullet; end
  def _BulletList; end
  def _CharEntity; end
  def _Code; end
  def _CodeFence; end
  def _DecEntity; end
  def _DefinitionList; end
  def _DefinitionListDefinition; end
  def _DefinitionListItem; end
  def _DefinitionListLabel; end
  def _Digit; end
  def _Doc; end
  def _Emph; end
  def _EmphStar; end
  def _EmphUl; end
  def _EmptyTitle; end
  def _Endline; end
  def _Entity; end
  def _Enumerator; end
  def _Eof; end
  def _EscapedChar; end
  def _ExplicitLink; end
  def _ExtendedSpecialChar; end
  def _Heading; end
  def _HexEntity; end
  def _HorizontalRule; end
  def _HtmlAnchor; end
  def _HtmlAttribute; end
  def _HtmlBlock; end
  def _HtmlBlockAddress; end
  def _HtmlBlockBlockquote; end
  def _HtmlBlockCenter; end
  def _HtmlBlockCloseAddress; end
  def _HtmlBlockCloseBlockquote; end
  def _HtmlBlockCloseCenter; end
  def _HtmlBlockCloseDd; end
  def _HtmlBlockCloseDir; end
  def _HtmlBlockCloseDiv; end
  def _HtmlBlockCloseDl; end
  def _HtmlBlockCloseDt; end
  def _HtmlBlockCloseFieldset; end
  def _HtmlBlockCloseForm; end
  def _HtmlBlockCloseFrameset; end
  def _HtmlBlockCloseH1; end
  def _HtmlBlockCloseH2; end
  def _HtmlBlockCloseH3; end
  def _HtmlBlockCloseH4; end
  def _HtmlBlockCloseH5; end
  def _HtmlBlockCloseH6; end
  def _HtmlBlockCloseHead; end
  def _HtmlBlockCloseLi; end
  def _HtmlBlockCloseMenu; end
  def _HtmlBlockCloseNoframes; end
  def _HtmlBlockCloseNoscript; end
  def _HtmlBlockCloseOl; end
  def _HtmlBlockCloseP; end
  def _HtmlBlockClosePre; end
  def _HtmlBlockCloseScript; end
  def _HtmlBlockCloseTable; end
  def _HtmlBlockCloseTbody; end
  def _HtmlBlockCloseTd; end
  def _HtmlBlockCloseTfoot; end
  def _HtmlBlockCloseTh; end
  def _HtmlBlockCloseThead; end
  def _HtmlBlockCloseTr; end
  def _HtmlBlockCloseUl; end
  def _HtmlBlockDd; end
  def _HtmlBlockDir; end
  def _HtmlBlockDiv; end
  def _HtmlBlockDl; end
  def _HtmlBlockDt; end
  def _HtmlBlockFieldset; end
  def _HtmlBlockForm; end
  def _HtmlBlockFrameset; end
  def _HtmlBlockH1; end
  def _HtmlBlockH2; end
  def _HtmlBlockH3; end
  def _HtmlBlockH4; end
  def _HtmlBlockH5; end
  def _HtmlBlockH6; end
  def _HtmlBlockHead; end
  def _HtmlBlockInTags; end
  def _HtmlBlockLi; end
  def _HtmlBlockMenu; end
  def _HtmlBlockNoframes; end
  def _HtmlBlockNoscript; end
  def _HtmlBlockOl; end
  def _HtmlBlockOpenAddress; end
  def _HtmlBlockOpenBlockquote; end
  def _HtmlBlockOpenCenter; end
  def _HtmlBlockOpenDd; end
  def _HtmlBlockOpenDir; end
  def _HtmlBlockOpenDiv; end
  def _HtmlBlockOpenDl; end
  def _HtmlBlockOpenDt; end
  def _HtmlBlockOpenFieldset; end
  def _HtmlBlockOpenForm; end
  def _HtmlBlockOpenFrameset; end
  def _HtmlBlockOpenH1; end
  def _HtmlBlockOpenH2; end
  def _HtmlBlockOpenH3; end
  def _HtmlBlockOpenH4; end
  def _HtmlBlockOpenH5; end
  def _HtmlBlockOpenH6; end
  def _HtmlBlockOpenHead; end
  def _HtmlBlockOpenLi; end
  def _HtmlBlockOpenMenu; end
  def _HtmlBlockOpenNoframes; end
  def _HtmlBlockOpenNoscript; end
  def _HtmlBlockOpenOl; end
  def _HtmlBlockOpenP; end
  def _HtmlBlockOpenPre; end
  def _HtmlBlockOpenScript; end
  def _HtmlBlockOpenTable; end
  def _HtmlBlockOpenTbody; end
  def _HtmlBlockOpenTd; end
  def _HtmlBlockOpenTfoot; end
  def _HtmlBlockOpenTh; end
  def _HtmlBlockOpenThead; end
  def _HtmlBlockOpenTr; end
  def _HtmlBlockOpenUl; end
  def _HtmlBlockP; end
  def _HtmlBlockPre; end
  def _HtmlBlockScript; end
  def _HtmlBlockSelfClosing; end
  def _HtmlBlockTable; end
  def _HtmlBlockTbody; end
  def _HtmlBlockTd; end
  def _HtmlBlockTfoot; end
  def _HtmlBlockTh; end
  def _HtmlBlockThead; end
  def _HtmlBlockTr; end
  def _HtmlBlockType; end
  def _HtmlBlockUl; end
  def _HtmlCloseAnchor; end
  def _HtmlComment; end
  def _HtmlOpenAnchor; end
  def _HtmlTag; end
  def _HtmlUnclosed; end
  def _HtmlUnclosedType; end
  def _Image; end
  def _InStyleTags; end
  def _Indent; end
  def _IndentedLine; end
  def _Inline; end
  def _InlineNote; end
  def _Inlines; end
  def _Label; end
  def _Line; end
  def _LineBreak; end
  def _Link; end
  def _ListBlock; end
  def _ListBlockLine; end
  def _ListContinuationBlock; end
  def _ListItem; end
  def _ListItemTight; end
  def _ListLoose; end
  def _ListTight; end
  def _Newline; end
  def _NonblankIndentedLine; end
  def _NonindentSpace; end
  def _Nonspacechar; end
  def _NormalChar; end
  def _NormalEndline; end
  def _Note; end
  def _NoteReference; end
  def _Notes; end
  def _OptionallyIndentedLine; end
  def _OrderedList; end
  def _Para; end
  def _Plain; end
  def _Quoted; end
  def _RawHtml; end
  def _RawLine; end
  def _RawNoteBlock; end
  def _RawNoteReference; end
  def _RefSrc; end
  def _RefTitle; end
  def _RefTitleDouble; end
  def _RefTitleParens; end
  def _RefTitleSingle; end
  def _Reference; end
  def _ReferenceLink; end
  def _ReferenceLinkDouble; end
  def _ReferenceLinkSingle; end
  def _References; end
  def _SetextBottom1; end
  def _SetextBottom2; end
  def _SetextHeading; end
  def _SetextHeading1; end
  def _SetextHeading2; end
  def _SkipBlock; end
  def _Source; end
  def _SourceContents; end
  def _Sp; end
  def _Space; end
  def _Spacechar; end
  def _SpecialChar; end
  def _Spnl; end
  def _StarLine; end
  def _StartList; end
  def _Str; end
  def _StrChunk; end
  def _Strike; end
  def _Strong; end
  def _StrongStar; end
  def _StrongUl; end
  def _StyleBlock; end
  def _StyleClose; end
  def _StyleOpen; end
  def _Symbol; end
  def _TerminalEndline; end
  def _Ticks1; end
  def _Ticks2; end
  def _Ticks3; end
  def _Ticks4; end
  def _Ticks5; end
  def _Title; end
  def _TitleDouble; end
  def _TitleSingle; end
  def _UlLine; end
  def _UlOrStarLine; end
  def _Verbatim; end
  def _VerbatimChunk; end
  def _Whitespace; end
  def _root; end
  def apply(rule); end
  def apply_with_args(rule, *args); end
  def break_on_newline=(enable); end
  def break_on_newline?; end
  def css=(enable); end
  def css?; end
  def current_column(target = _); end
  def current_line(target = _); end
  def definition_lists=(enable); end
  def definition_lists?; end
  def emphasis(text); end
  def extension(name, enable); end
  def extension?(name); end
  def external_invoke(other, rule, *args); end
  def failed_rule; end
  def failing_rule_offset; end
  def failure_caret; end
  def failure_character; end
  def failure_info; end
  def failure_oneline; end
  def get_byte; end
  def get_text(start); end
  def github=(enable); end
  def github?; end
  def grow_lr(rule, args, start_pos, m); end
  def html=(enable); end
  def html?; end
  def inner_parse(text); end
  def lines; end
  def link_to(content, label = _, text = _); end
  def list_item_from(unparsed); end
  def match_string(str); end
  def note(label); end
  def note_for(ref); end
  def notes=(enable); end
  def notes?; end
  def paragraph(parts); end
  def parse(markdown); end
  def peg_parse(rule = _); end
  def pos; end
  def pos=(_); end
  def raise_error; end
  def reference(label, link); end
  def result; end
  def result=(_); end
  def scan(reg); end
  def set_failed_rule(name); end
  def set_string(string, pos); end
  def setup_foreign_grammar; end
  def setup_parser(str, debug = _); end
  def show_error(io = _); end
  def show_pos; end
  def strike(text); end
  def strike=(enable); end
  def strike?; end
  def string; end
  def strong(text); end

  private

  def orig_initialize(str, debug = _); end

  def self.extension(name); end
  def self.parse(markdown); end
  def self.rule_info(name, rendered); end
end

RDoc::Markdown::DEFAULT_EXTENSIONS = T.let(T.unsafe(nil), Array)

RDoc::Markdown::EXTENSIONS = T.let(T.unsafe(nil), Array)

RDoc::Markdown::HTML_ENTITIES = T.let(T.unsafe(nil), Hash)

class RDoc::Markdown::Literals
  def initialize(str, debug = _); end

  def _Alphanumeric; end
  def _AlphanumericAscii; end
  def _BOM; end
  def _Newline; end
  def _NonAlphanumeric; end
  def _Spacechar; end
  def apply(rule); end
  def apply_with_args(rule, *args); end
  def current_column(target = _); end
  def current_line(target = _); end
  def external_invoke(other, rule, *args); end
  def failed_rule; end
  def failing_rule_offset; end
  def failure_caret; end
  def failure_character; end
  def failure_info; end
  def failure_oneline; end
  def get_byte; end
  def get_text(start); end
  def grow_lr(rule, args, start_pos, m); end
  def lines; end
  def match_string(str); end
  def parse(rule = _); end
  def pos; end
  def pos=(_); end
  def raise_error; end
  def result; end
  def result=(_); end
  def scan(reg); end
  def set_failed_rule(name); end
  def set_string(string, pos); end
  def setup_foreign_grammar; end
  def setup_parser(str, debug = _); end
  def show_error(io = _); end
  def show_pos; end
  def string; end

  def self.rule_info(name, rendered); end
end

class RDoc::Markdown::Literals::MemoEntry
  def initialize(ans, pos); end

  def ans; end
  def left_rec; end
  def left_rec=(_); end
  def move!(ans, pos, result); end
  def pos; end
  def result; end
  def set; end
end

class RDoc::Markdown::Literals::ParseError < ::RuntimeError
end

class RDoc::Markdown::Literals::RuleInfo
  def initialize(name, rendered); end

  def name; end
  def rendered; end
end

RDoc::Markdown::Literals::Rules = T.let(T.unsafe(nil), Hash)

class RDoc::Markdown::MemoEntry
  def initialize(ans, pos); end

  def ans; end
  def left_rec; end
  def left_rec=(_); end
  def move!(ans, pos, result); end
  def pos; end
  def result; end
  def set; end
end

class RDoc::Markdown::ParseError < ::RuntimeError
end

class RDoc::Markdown::RuleInfo
  def initialize(name, rendered); end

  def name; end
  def rendered; end
end

RDoc::Markdown::Rules = T.let(T.unsafe(nil), Hash)

class RDoc::Markup
  def initialize(attribute_manager = _); end

  def add_html(tag, name); end
  def add_regexp_handling(pattern, name); end
  def add_word_pair(start, stop, name); end
  def attribute_manager; end
  def convert(input, formatter); end

  def self.parse(str); end
end

class RDoc::Markup::AttrChanger < ::Struct
  def inspect; end
  def to_s; end
  def turn_off; end
  def turn_off=(_); end
  def turn_on; end
  def turn_on=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

class RDoc::Markup::AttrSpan
  def initialize(length); end

  def [](n); end
  def set_attrs(start, length, bits); end
end

class RDoc::Markup::AttributeManager
  def initialize; end

  def add_html(tag, name); end
  def add_regexp_handling(pattern, name); end
  def add_word_pair(start, stop, name); end
  def attribute(turn_on, turn_off); end
  def attributes; end
  def change_attribute(current, new); end
  def changed_attribute_by_name(current_set, new_set); end
  def convert_attrs(str, attrs); end
  def convert_html(str, attrs); end
  def convert_regexp_handlings(str, attrs); end
  def copy_string(start_pos, end_pos); end
  def display_attributes; end
  def flow(str); end
  def html_tags; end
  def mask_protected_sequences; end
  def matching_word_pairs; end
  def protectable; end
  def regexp_handlings; end
  def split_into_flow; end
  def unmask_protected_sequences; end
  def word_pair_map; end
end

RDoc::Markup::AttributeManager::A_PROTECT = T.let(T.unsafe(nil), Integer)

RDoc::Markup::AttributeManager::NULL = T.let(T.unsafe(nil), String)

RDoc::Markup::AttributeManager::PROTECT_ATTR = T.let(T.unsafe(nil), String)

class RDoc::Markup::Attributes
  def initialize; end

  def as_string(bitmap); end
  def bitmap_for(name); end
  def each_name_of(bitmap); end
  def regexp_handling; end
end

class RDoc::Markup::BlankLine
  def accept(visitor); end
  def pretty_print(q); end

  def self.new; end
end

class RDoc::Markup::BlockQuote < ::RDoc::Markup::Raw
  def accept(visitor); end
end

class RDoc::Markup::Document
  include(::Enumerable)

  def initialize(*parts); end

  def <<(part); end
  def ==(other); end
  def accept(visitor); end
  def concat(parts); end
  def each(&block); end
  def empty?; end
  def file; end
  def file=(location); end
  def merge(other); end
  def merged?; end
  def omit_headings_below; end
  def omit_headings_below=(_); end
  def parts; end
  def pretty_print(q); end
  def push(*parts); end
  def table_of_contents; end
end

class RDoc::Markup::Formatter
  def initialize(options, markup = _); end

  def accept_document(document); end
  def add_regexp_handling_RDOCLINK; end
  def add_regexp_handling_TIDYLINK; end
  def add_tag(name, start, stop); end
  def annotate(tag); end
  def convert(content); end
  def convert_flow(flow); end
  def convert_regexp_handling(target); end
  def convert_string(string); end
  def ignore(*node); end
  def in_tt?; end
  def off_tags(res, item); end
  def on_tags(res, item); end
  def parse_url(url); end
  def tt?(tag); end

  def self.gen_relative_url(path, target); end
end

class RDoc::Markup::Formatter::InlineTag < ::Struct
  def bit; end
  def bit=(_); end
  def off; end
  def off=(_); end
  def on; end
  def on=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

class RDoc::Markup::HardBreak
  def ==(other); end
  def accept(visitor); end
  def pretty_print(q); end

  def self.new; end
end

class RDoc::Markup::Heading < ::Struct
  def accept(visitor); end
  def aref; end
  def label(context = _); end
  def level; end
  def level=(_); end
  def plain_html; end
  def pretty_print(q); end
  def text; end
  def text=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
  def self.to_html; end
  def self.to_label; end
end

class RDoc::Markup::Include
  def initialize(file, include_path); end

  def ==(other); end
  def file; end
  def include_path; end
  def pretty_print(q); end
end

class RDoc::Markup::IndentedParagraph < ::RDoc::Markup::Raw
  def initialize(indent, *parts); end

  def ==(other); end
  def accept(visitor); end
  def indent; end
  def text(hard_break = _); end
end

class RDoc::Markup::List
  def initialize(type = _, *items); end

  def <<(item); end
  def ==(other); end
  def accept(visitor); end
  def empty?; end
  def items; end
  def last; end
  def pretty_print(q); end
  def push(*items); end
  def type; end
  def type=(_); end
end

class RDoc::Markup::ListItem
  def initialize(label = _, *parts); end

  def <<(part); end
  def ==(other); end
  def accept(visitor); end
  def empty?; end
  def label; end
  def label=(_); end
  def length; end
  def parts; end
  def pretty_print(q); end
  def push(*parts); end
end

class RDoc::Markup::Paragraph < ::RDoc::Markup::Raw
  def accept(visitor); end
  def text(hard_break = _); end
end

class RDoc::Markup::Parser
  include(::RDoc::Text)

  def initialize; end

  def build_heading(level); end
  def build_list(margin); end
  def build_paragraph(margin); end
  def build_verbatim(margin); end
  def debug; end
  def debug=(_); end
  def get; end
  def parse(parent, indent = _); end
  def parse_text(parent, indent); end
  def peek_token; end
  def setup_scanner(input); end
  def skip(token_type, error = _); end
  def tokenize(input); end
  def tokens; end
  def unget; end

  def self.parse(str); end
  def self.tokenize(str); end
end

class RDoc::Markup::Parser::Error < ::RuntimeError
end

RDoc::Markup::Parser::LIST_TOKENS = T.let(T.unsafe(nil), Array)

class RDoc::Markup::Parser::MyStringScanner
  def initialize(input); end

  def [](i); end
  def eos?; end
  def matched; end
  def newline!; end
  def pos; end
  def scan(re); end
  def unscan(s); end
end

class RDoc::Markup::Parser::ParseError < ::RDoc::Markup::Parser::Error
end

class RDoc::Markup::PreProcess
  def initialize(input_file_name, include_path); end

  def find_include_file(name); end
  def handle(text, code_object = _, &block); end
  def handle_directive(prefix, directive, param, code_object = _, encoding = _); end
  def include_file(name, indent, encoding); end
  def options; end
  def options=(_); end

  def self.post_process(&block); end
  def self.post_processors; end
  def self.register(directive, &block); end
  def self.registered; end
  def self.reset; end
end

class RDoc::Markup::Raw
  def initialize(*parts); end

  def <<(text); end
  def ==(other); end
  def accept(visitor); end
  def merge(other); end
  def parts; end
  def pretty_print(q); end
  def push(*texts); end
  def text; end
end

class RDoc::Markup::RegexpHandling
  def initialize(type, text); end

  def ==(o); end
  def inspect; end
  def text; end
  def text=(_); end
  def to_s; end
  def type; end
end

class RDoc::Markup::Rule < ::Struct
  def accept(visitor); end
  def pretty_print(q); end
end

class RDoc::Markup::ToAnsi < ::RDoc::Markup::ToRdoc
  def initialize(markup = _); end

  def accept_list_item_end(list_item); end
  def accept_list_item_start(list_item); end
  def init_tags; end
  def start_accepting; end
end

class RDoc::Markup::ToBs < ::RDoc::Markup::ToRdoc
  def initialize(markup = _); end

  def accept_heading(heading); end
  def annotate(tag); end
  def convert_regexp_handling(target); end
  def convert_string(string); end
  def init_tags; end
end

class RDoc::Markup::ToHtml < ::RDoc::Markup::Formatter
  include(::RDoc::Text)

  def initialize(options, markup = _); end

  def accept_blank_line(blank_line); end
  def accept_block_quote(block_quote); end
  def accept_heading(heading); end
  def accept_list_end(list); end
  def accept_list_item_end(list_item); end
  def accept_list_item_start(list_item); end
  def accept_list_start(list); end
  def accept_paragraph(paragraph); end
  def accept_raw(raw); end
  def accept_rule(rule); end
  def accept_verbatim(verbatim); end
  def code_object; end
  def code_object=(_); end
  def convert_string(text); end
  def end_accepting; end
  def from_path; end
  def from_path=(_); end
  def gen_url(url, text); end
  def handle_RDOCLINK(url); end
  def handle_regexp_HARD_BREAK(target); end
  def handle_regexp_HYPERLINK(target); end
  def handle_regexp_RDOCLINK(target); end
  def handle_regexp_TIDYLINK(target); end
  def html_list_name(list_type, open_tag); end
  def in_list_entry; end
  def init_tags; end
  def list; end
  def list_end_for(list_type); end
  def list_item_start(list_item, list_type); end
  def parseable?(text); end
  def res; end
  def start_accepting; end
  def to_html(item); end
end

RDoc::Markup::ToHtml::LIST_TYPE_TO_HTML = T.let(T.unsafe(nil), Hash)

class RDoc::Markup::ToHtmlCrossref < ::RDoc::Markup::ToHtml
  def initialize(options, from_path, context, markup = _); end

  def context; end
  def context=(_); end
  def cross_reference(name, text = _, code = _); end
  def gen_url(url, text); end
  def handle_regexp_CROSSREF(target); end
  def handle_regexp_HYPERLINK(target); end
  def handle_regexp_RDOCLINK(target); end
  def link(name, text, code = _); end
  def show_hash; end
  def show_hash=(_); end
end

RDoc::Markup::ToHtmlCrossref::ALL_CROSSREF_REGEXP = T.let(T.unsafe(nil), Regexp)

RDoc::Markup::ToHtmlCrossref::CLASS_REGEXP_STR = T.let(T.unsafe(nil), String)

RDoc::Markup::ToHtmlCrossref::CROSSREF_REGEXP = T.let(T.unsafe(nil), Regexp)

RDoc::Markup::ToHtmlCrossref::METHOD_REGEXP_STR = T.let(T.unsafe(nil), String)

class RDoc::Markup::ToHtmlSnippet < ::RDoc::Markup::ToHtml
  def initialize(options, characters = _, paragraphs = _, markup = _); end

  def accept_heading(heading); end
  def accept_list_item_end(list_item); end
  def accept_list_item_start(list_item); end
  def accept_list_start(list); end
  def accept_paragraph(paragraph); end
  def accept_raw(*node); end
  def accept_rule(*node); end
  def accept_verbatim(verbatim); end
  def add_paragraph; end
  def character_limit; end
  def characters; end
  def convert(content); end
  def convert_flow(flow); end
  def gen_url(url, text); end
  def handle_regexp_CROSSREF(target); end
  def handle_regexp_HARD_BREAK(target); end
  def html_list_name(list_type, open_tag); end
  def list_item_start(list_item, list_type); end
  def mask; end
  def off_tags(res, item); end
  def on_tags(res, item); end
  def paragraph_limit; end
  def paragraphs; end
  def start_accepting; end
  def truncate(text); end
end

class RDoc::Markup::ToJoinedParagraph < ::RDoc::Markup::Formatter
  def initialize; end

  def accept_block_quote(*node); end
  def accept_heading(*node); end
  def accept_list_end(*node); end
  def accept_list_item_end(*node); end
  def accept_list_item_start(*node); end
  def accept_list_start(*node); end
  def accept_paragraph(paragraph); end
  def accept_raw(*node); end
  def accept_rule(*node); end
  def accept_verbatim(*node); end
  def end_accepting; end
  def start_accepting; end
end

class RDoc::Markup::ToLabel < ::RDoc::Markup::Formatter
  def initialize(markup = _); end

  def accept_blank_line(*node); end
  def accept_block_quote(*node); end
  def accept_heading(*node); end
  def accept_list_end(*node); end
  def accept_list_item_end(*node); end
  def accept_list_item_start(*node); end
  def accept_list_start(*node); end
  def accept_paragraph(*node); end
  def accept_raw(*node); end
  def accept_rule(*node); end
  def accept_verbatim(*node); end
  def convert(text); end
  def end_accepting(*node); end
  def handle_regexp_CROSSREF(target); end
  def handle_regexp_HARD_BREAK(*node); end
  def handle_regexp_TIDYLINK(target); end
  def res; end
  def start_accepting(*node); end
end

class RDoc::Markup::ToMarkdown < ::RDoc::Markup::ToRdoc
  def initialize(markup = _); end

  def accept_list_end(list); end
  def accept_list_item_end(list_item); end
  def accept_list_item_start(list_item); end
  def accept_list_start(list); end
  def accept_rule(rule); end
  def accept_verbatim(verbatim); end
  def gen_url(url, text); end
  def handle_rdoc_link(url); end
  def handle_regexp_HARD_BREAK(target); end
  def handle_regexp_RDOCLINK(target); end
  def handle_regexp_TIDYLINK(target); end
  def init_tags; end
end

class RDoc::Markup::ToRdoc < ::RDoc::Markup::Formatter
  def initialize(markup = _); end

  def accept_blank_line(blank_line); end
  def accept_block_quote(block_quote); end
  def accept_heading(heading); end
  def accept_indented_paragraph(paragraph); end
  def accept_list_end(list); end
  def accept_list_item_end(list_item); end
  def accept_list_item_start(list_item); end
  def accept_list_start(list); end
  def accept_paragraph(paragraph); end
  def accept_raw(raw); end
  def accept_rule(rule); end
  def accept_verbatim(verbatim); end
  def attributes(text); end
  def end_accepting; end
  def handle_regexp_HARD_BREAK(target); end
  def handle_regexp_SUPPRESSED_CROSSREF(target); end
  def indent; end
  def indent=(_); end
  def init_tags; end
  def list_index; end
  def list_type; end
  def list_width; end
  def prefix; end
  def res; end
  def start_accepting; end
  def use_prefix; end
  def width; end
  def width=(_); end
  def wrap(text); end
end

class RDoc::Markup::ToTableOfContents < ::RDoc::Markup::Formatter
  def initialize; end

  def accept_blank_line(*node); end
  def accept_block_quote(*node); end
  def accept_document(document); end
  def accept_heading(heading); end
  def accept_list_end(*node); end
  def accept_list_end_bullet(*node); end
  def accept_list_item_end(*node); end
  def accept_list_item_start(*node); end
  def accept_list_start(*node); end
  def accept_paragraph(*node); end
  def accept_raw(*node); end
  def accept_rule(*node); end
  def accept_verbatim(*node); end
  def end_accepting; end
  def omit_headings_below; end
  def omit_headings_below=(_); end
  def res; end
  def start_accepting; end
  def suppressed?(heading); end

  def self.to_toc; end
end

class RDoc::Markup::ToTest < ::RDoc::Markup::Formatter
  def accept_blank_line(blank_line); end
  def accept_heading(heading); end
  def accept_list_end(list); end
  def accept_list_item_end(list_item); end
  def accept_list_item_start(list_item); end
  def accept_list_start(list); end
  def accept_paragraph(paragraph); end
  def accept_raw(raw); end
  def accept_rule(rule); end
  def accept_verbatim(verbatim); end
  def end_accepting; end
  def start_accepting; end
end

class RDoc::Markup::ToTtOnly < ::RDoc::Markup::Formatter
  def initialize(markup = _); end

  def accept_blank_line(markup_item); end
  def accept_block_quote(block_quote); end
  def accept_heading(markup_item); end
  def accept_list_end(list); end
  def accept_list_item_end(markup_item); end
  def accept_list_item_start(list_item); end
  def accept_list_start(list); end
  def accept_paragraph(paragraph); end
  def accept_raw(markup_item); end
  def accept_rule(markup_item); end
  def accept_verbatim(markup_item); end
  def do_nothing(markup_item); end
  def end_accepting; end
  def list_type; end
  def res; end
  def start_accepting; end
  def tt_sections(text); end
end

class RDoc::Markup::Verbatim < ::RDoc::Markup::Raw
  def initialize(*parts); end

  def ==(other); end
  def accept(visitor); end
  def format; end
  def format=(_); end
  def normalize; end
  def pretty_print(q); end
  def ruby?; end
  def text; end
end

class RDoc::MetaMethod < ::RDoc::AnyMethod
end

class RDoc::MethodAttr < ::RDoc::CodeObject
  include(::Comparable)

  def initialize(text, name); end

  def <=>(other); end
  def ==(other); end
  def add_alias(an_alias, context); end
  def add_line_numbers(src); end
  def aliases; end
  def aref; end
  def aref_prefix; end
  def arglists; end
  def block_params; end
  def block_params=(value); end
  def call_seq; end
  def call_seq=(_); end
  def documented?; end
  def find_method_or_attribute(name); end
  def find_see; end
  def full_name; end
  def html_name; end
  def initialize_visibility; end
  def inspect; end
  def is_alias_for; end
  def is_alias_for=(_); end
  def markup_code; end
  def name; end
  def name=(_); end
  def name_prefix; end
  def output_name(context); end
  def param_seq; end
  def params; end
  def params=(_); end
  def parent_name; end
  def path; end
  def pretty_name; end
  def pretty_print(q); end
  def search_record; end
  def see; end
  def singleton; end
  def singleton=(_); end
  def store=(store); end
  def text; end
  def to_s; end
  def type; end
  def visibility; end
  def visibility=(_); end

  private

  def initialize_copy(other); end
end

class RDoc::Mixin < ::RDoc::CodeObject
  def initialize(name, comment); end

  def <=>(other); end
  def ==(other); end
  def eql?(other); end
  def full_name; end
  def hash; end
  def inspect; end
  def module; end
  def name; end
  def name=(_); end
  def store=(store); end
  def to_s; end
end

class RDoc::NormalClass < ::RDoc::ClassModule
  def ancestors; end
  def aref_prefix; end
  def definition; end
  def direct_ancestors; end
  def inspect; end
  def pretty_print(q); end
  def to_s; end
end

class RDoc::NormalModule < ::RDoc::ClassModule
  def aref_prefix; end
  def definition; end
  def inspect; end
  def module?; end
  def pretty_print(q); end
  def superclass; end
end

class RDoc::Options
  def initialize; end

  def ==(other); end
  def charset; end
  def charset=(_); end
  def check_files; end
  def check_generator; end
  def coverage_report; end
  def coverage_report=(_); end
  def default_title=(string); end
  def dry_run; end
  def dry_run=(_); end
  def encode_with(coder); end
  def encoding; end
  def encoding=(_); end
  def exclude; end
  def exclude=(_); end
  def files; end
  def files=(_); end
  def finish; end
  def finish_page_dir; end
  def force_output; end
  def force_output=(_); end
  def force_update; end
  def force_update=(_); end
  def formatter; end
  def formatter=(_); end
  def generator; end
  def generator=(_); end
  def generator_descriptions; end
  def generator_name; end
  def generator_options; end
  def generator_options=(_); end
  def github; end
  def github=(_); end
  def hyperlink_all; end
  def hyperlink_all=(_); end
  def init_ivars; end
  def init_with(map); end
  def line_numbers; end
  def line_numbers=(_); end
  def locale; end
  def locale=(_); end
  def locale_dir; end
  def locale_dir=(_); end
  def main_page; end
  def main_page=(_); end
  def markup; end
  def markup=(_); end
  def op_dir; end
  def op_dir=(_); end
  def option_parser; end
  def option_parser=(_); end
  def output_decoration; end
  def output_decoration=(_); end
  def page_dir; end
  def page_dir=(_); end
  def parse(argv); end
  def pipe; end
  def pipe=(_); end
  def quiet; end
  def quiet=(bool); end
  def rdoc_include; end
  def rdoc_include=(_); end
  def root; end
  def root=(_); end
  def sanitize_path(path); end
  def search_index; end
  def search_index=(_); end
  def setup_generator(generator_name = _); end
  def show_hash; end
  def show_hash=(_); end
  def static_path; end
  def static_path=(_); end
  def tab_width; end
  def tab_width=(_); end
  def template; end
  def template=(_); end
  def template_dir; end
  def template_dir=(_); end
  def template_dir_for(template); end
  def template_stylesheets; end
  def template_stylesheets=(_); end
  def title; end
  def title=(_); end
  def update_output_dir; end
  def update_output_dir=(_); end
  def verbosity; end
  def verbosity=(_); end
  def visibility; end
  def visibility=(visibility); end
  def warn(message); end
  def webcvs; end
  def webcvs=(_); end
  def write_options; end
  def yaml_initialize(tag, map); end
end

RDoc::Options::DEPRECATED = T.let(T.unsafe(nil), Hash)

RDoc::Options::Directory = T.let(T.unsafe(nil), Object)

RDoc::Options::Path = T.let(T.unsafe(nil), Object)

RDoc::Options::PathArray = T.let(T.unsafe(nil), Object)

RDoc::Options::SPECIAL = T.let(T.unsafe(nil), Array)

RDoc::Options::Template = T.let(T.unsafe(nil), Object)

class RDoc::Parser
  def initialize(top_level, file_name, content, options, stats); end

  def file_name; end

  def self.alias_extension(old_ext, new_ext); end
  def self.binary?(file); end
  def self.can_parse(file_name); end
  def self.can_parse_by_name(file_name); end
  def self.check_modeline(file_name); end
  def self.for(top_level, file_name, content, options, stats); end
  def self.parse_files_matching(regexp); end
  def self.parsers; end
  def self.remove_modeline(content); end
  def self.use_markup(content); end
  def self.zip?(file); end
end

class RDoc::Parser::C < ::RDoc::Parser
  include(::RDoc::Text)

  def initialize(top_level, file_name, content, options, stats); end

  def classes; end
  def content; end
  def content=(_); end
  def deduplicate_call_seq; end
  def deduplicate_method_name(class_obj, method_name); end
  def do_aliases; end
  def do_attrs; end
  def do_boot_defclass; end
  def do_classes_and_modules; end
  def do_constants; end
  def do_includes; end
  def do_methods; end
  def do_missing; end
  def enclosure_dependencies; end
  def find_alias_comment(class_name, new_name, old_name); end
  def find_attr_comment(var_name, attr_name, read = _, write = _); end
  def find_body(class_name, meth_name, meth_obj, file_content, quiet = _); end
  def find_class(raw_name, name); end
  def find_class_comment(class_name, class_mod); end
  def find_const_comment(type, const_name, class_name = _); end
  def find_modifiers(comment, meth_obj); end
  def find_override_comment(class_name, meth_obj); end
  def gen_body_table(file_content); end
  def gen_const_table(file_content); end
  def handle_attr(var_name, attr_name, read, write); end
  def handle_class_module(var_name, type, class_name, parent, in_module); end
  def handle_constants(type, var_name, const_name, definition); end
  def handle_ifdefs_in(body); end
  def handle_method(type, var_name, meth_name, function, param_count, source_file = _); end
  def handle_singleton(sclass_var, class_var); end
  def handle_tab_width(body); end
  def known_classes; end
  def load_variable_map(map_name); end
  def look_for_directives_in(context, comment); end
  def missing_dependencies; end
  def rb_scan_args(method_body); end
  def remove_commented_out_lines; end
  def scan; end
  def singleton_classes; end
  def top_level; end
end

class RDoc::Parser::ChangeLog < ::RDoc::Parser
  include(::RDoc::Parser::Text)

  def continue_entry_body(entry_body, continuation); end
  def create_document(groups); end
  def create_entries(entries); end
  def create_items(items); end
  def group_entries(entries); end
  def parse_entries; end
  def scan; end
end

class RDoc::Parser::Markdown < ::RDoc::Parser
  include(::RDoc::Parser::Text)

  def scan; end
end

class RDoc::Parser::RD < ::RDoc::Parser
  include(::RDoc::Parser::Text)

  def scan; end
end

class RDoc::Parser::RipperStateLex
  def initialize(code); end

  def get_squashed_tk; end

  private

  def get_embdoc_tk(tk); end
  def get_heredoc_tk(heredoc_name, indent); end
  def get_op_tk(tk); end
  def get_regexp_tk(tk); end
  def get_string_tk(tk); end
  def get_symbol_tk(tk); end
  def get_words_tk(tk); end
  def heredoc_end?(name, indent, tk); end
  def retrieve_heredoc_info(tk); end

  def self.end?(token); end
  def self.parse(code); end
end

RDoc::Parser::RipperStateLex::EXPR_ARG = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_ARG_ANY = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_BEG = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_BEG_ANY = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_CLASS = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_CMDARG = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_DOT = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_END = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_ENDARG = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_ENDFN = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_END_ANY = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_FITEM = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_FNAME = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_LABEL = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_LABELED = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_MID = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_NONE = T.let(T.unsafe(nil), Integer)

RDoc::Parser::RipperStateLex::EXPR_VALUE = T.let(T.unsafe(nil), Integer)

class RDoc::Parser::RipperStateLex::InnerStateLex < ::Ripper::Filter
  def initialize(code); end

  def on_default(event, tok, data); end
end

RDoc::Parser::RipperStateLex::RIPPER_HAS_LEX_STATE = T.let(T.unsafe(nil), TrueClass)

class RDoc::Parser::RipperStateLex::Token < ::Struct
  def char_no; end
  def char_no=(_); end
  def kind; end
  def kind=(_); end
  def line_no; end
  def line_no=(_); end
  def state; end
  def state=(_); end
  def text; end
  def text=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

class RDoc::Parser::Ruby < ::RDoc::Parser
  include(::RDoc::Parser::RubyTools)
  include(::RDoc::TokenStream)

  def initialize(top_level, file_name, content, options, stats); end

  def collect_first_comment; end
  def consume_trailing_spaces; end
  def create_attr(container, single, name, rw, comment); end
  def create_module_alias(container, constant, rhs_name); end
  def error(msg); end
  def get_bool; end
  def get_class_or_module(container, ignore_constants = _); end
  def get_class_specification; end
  def get_constant; end
  def get_end_token(tk); end
  def get_included_module_with_optional_parens; end
  def get_method_container(container, name_t); end
  def get_symbol_or_name; end
  def get_tkread_clean(pattern, replacement); end
  def get_visibility_information(tk, single); end
  def look_for_directives_in(container, comment); end
  def make_message(message); end
  def new_comment(comment); end
  def parse_alias(context, single, tk, comment); end
  def parse_attr(context, single, tk, comment); end
  def parse_attr_accessor(context, single, tk, comment); end
  def parse_call_parameters(tk); end
  def parse_class(container, single, tk, comment); end
  def parse_class_regular(container, declaration_context, single, name_t, given_name, comment); end
  def parse_class_singleton(container, name, comment); end
  def parse_comment(container, tk, comment); end
  def parse_comment_attr(container, type, name, comment); end
  def parse_comment_ghost(container, text, name, column, line_no, comment); end
  def parse_comment_tomdoc(container, tk, comment); end
  def parse_constant(container, tk, comment, ignore_constants = _); end
  def parse_constant_body(container, constant, is_array_or_hash); end
  def parse_constant_visibility(container, single, tk); end
  def parse_extend_or_include(klass, container, comment); end
  def parse_identifier(container, single, tk, comment); end
  def parse_meta_attr(context, single, tk, comment); end
  def parse_meta_method(container, single, tk, comment); end
  def parse_meta_method_name(comment, tk); end
  def parse_meta_method_params(container, single, meth, tk, comment); end
  def parse_method(container, single, tk, comment); end
  def parse_method_dummy(container); end
  def parse_method_name(container); end
  def parse_method_name_regular(container, name_t); end
  def parse_method_name_singleton(container, name_t); end
  def parse_method_or_yield_parameters(method = _, modifiers = _); end
  def parse_method_parameters(method); end
  def parse_method_params_and_body(container, single, meth, added_container); end
  def parse_module(container, single, tk, comment); end
  def parse_require(context, comment); end
  def parse_rescue; end
  def parse_statements(container, single = _, current_method = _, comment = _); end
  def parse_symbol_arg(no = _); end
  def parse_symbol_arg_paren(no); end
  def parse_symbol_arg_space(no, tk); end
  def parse_symbol_in_arg; end
  def parse_top_level_statements(container); end
  def parse_visibility(container, single, tk); end
  def parse_yield(context, single, tk, method); end
  def read_directive(allowed); end
  def read_documentation_modifiers(context, allowed); end
  def record_location(container); end
  def retrieve_comment_body(tk); end
  def scan; end
  def skip_for_variable; end
  def skip_method(container); end
  def skip_optional_do_after_expression; end
  def skip_tkspace_comment(skip_nl = _); end
  def suppress_parents(container, ancestor); end
  def tk_nl?(tk); end
  def update_visibility(container, vis_type, vis, singleton); end
  def warn(message); end
end

RDoc::Parser::Ruby::NORMAL = T.let(T.unsafe(nil), String)

RDoc::Parser::Ruby::SINGLE = T.let(T.unsafe(nil), String)

module RDoc::Parser::RubyTools
  def add_token_listener(obj); end
  def get_tk; end
  def get_tk_until(*tokens); end
  def get_tkread; end
  def peek_read; end
  def peek_tk; end
  def remove_token_listener(obj); end
  def reset; end
  def skip_tkspace; end
  def skip_tkspace_without_nl; end
  def token_listener(obj); end
  def unget_tk(tk); end
end

class RDoc::Parser::Simple < ::RDoc::Parser
  include(::RDoc::Parser::Text)

  def initialize(top_level, file_name, content, options, stats); end

  def content; end
  def remove_coding_comment(text); end
  def remove_private_comment(comment); end
  def scan; end
end

module RDoc::Parser::Text
end

class RDoc::RD
  def self.parse(rd); end
end

class RDoc::RD::BlockParser < ::Racc::Parser
  def initialize; end

  def _reduce_1(val, _values, result); end
  def _reduce_10(val, _values, result); end
  def _reduce_11(val, _values, result); end
  def _reduce_12(val, _values, result); end
  def _reduce_13(val, _values, result); end
  def _reduce_14(val, _values, result); end
  def _reduce_15(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_17(val, _values, result); end
  def _reduce_18(val, _values, result); end
  def _reduce_19(val, _values, result); end
  def _reduce_2(val, _values, result); end
  def _reduce_20(val, _values, result); end
  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end
  def _reduce_27(val, _values, result); end
  def _reduce_28(val, _values, result); end
  def _reduce_29(val, _values, result); end
  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_33(val, _values, result); end
  def _reduce_34(val, _values, result); end
  def _reduce_35(val, _values, result); end
  def _reduce_36(val, _values, result); end
  def _reduce_37(val, _values, result); end
  def _reduce_38(val, _values, result); end
  def _reduce_39(val, _values, result); end
  def _reduce_4(val, _values, result); end
  def _reduce_40(val, _values, result); end
  def _reduce_41(val, _values, result); end
  def _reduce_42(val, _values, result); end
  def _reduce_43(val, _values, result); end
  def _reduce_44(val, _values, result); end
  def _reduce_45(val, _values, result); end
  def _reduce_46(val, _values, result); end
  def _reduce_47(val, _values, result); end
  def _reduce_48(val, _values, result); end
  def _reduce_49(val, _values, result); end
  def _reduce_5(val, _values, result); end
  def _reduce_50(val, _values, result); end
  def _reduce_51(val, _values, result); end
  def _reduce_52(val, _values, result); end
  def _reduce_54(val, _values, result); end
  def _reduce_55(val, _values, result); end
  def _reduce_57(val, _values, result); end
  def _reduce_6(val, _values, result); end
  def _reduce_62(val, _values, result); end
  def _reduce_63(val, _values, result); end
  def _reduce_64(val, _values, result); end
  def _reduce_65(val, _values, result); end
  def _reduce_66(val, _values, result); end
  def _reduce_67(val, _values, result); end
  def _reduce_68(val, _values, result); end
  def _reduce_69(val, _values, result); end
  def _reduce_71(val, _values, result); end
  def _reduce_72(val, _values, result); end
  def _reduce_8(val, _values, result); end
  def _reduce_9(val, _values, result); end
  def _reduce_none(val, _values, result); end
  def add_footnote(content); end
  def add_label(label); end
  def content(values); end
  def footnotes; end
  def include_path; end
  def include_path=(_); end
  def labels; end
  def line_index; end
  def next_token; end
  def on_error(et, ev, _values); end
  def paragraph(value); end
  def parse(src); end

  private

  def cut_off(src); end
  def format_line_num(*line_numbers); end
  def get_included(file); end
  def if_current_indent_equal(indent); end
  def parse_subtree(src); end
  def set_term_to_element(parent, term); end
end

RDoc::RD::BlockParser::MARK_TO_LEVEL = T.let(T.unsafe(nil), Hash)

RDoc::RD::BlockParser::Racc_arg = T.let(T.unsafe(nil), Array)

RDoc::RD::BlockParser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

RDoc::RD::BlockParser::TMPFILE = T.let(T.unsafe(nil), Array)

class RDoc::RD::Inline
  def initialize(rdoc, reference); end

  def ==(other); end
  def append(more); end
  def inspect; end
  def rdoc; end
  def reference; end
  def to_s; end

  def self.new(rdoc, reference = _); end
end

class RDoc::RD::InlineParser < ::Racc::Parser
  def initialize(block_parser); end

  def _reduce_101(val, _values, result); end
  def _reduce_102(val, _values, result); end
  def _reduce_109(val, _values, result); end
  def _reduce_111(val, _values, result); end
  def _reduce_113(val, _values, result); end
  def _reduce_114(val, _values, result); end
  def _reduce_115(val, _values, result); end
  def _reduce_13(val, _values, result); end
  def _reduce_136(val, _values, result); end
  def _reduce_14(val, _values, result); end
  def _reduce_15(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_17(val, _values, result); end
  def _reduce_18(val, _values, result); end
  def _reduce_19(val, _values, result); end
  def _reduce_2(val, _values, result); end
  def _reduce_20(val, _values, result); end
  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end
  def _reduce_23(val, _values, result); end
  def _reduce_24(val, _values, result); end
  def _reduce_25(val, _values, result); end
  def _reduce_26(val, _values, result); end
  def _reduce_27(val, _values, result); end
  def _reduce_29(val, _values, result); end
  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_33(val, _values, result); end
  def _reduce_34(val, _values, result); end
  def _reduce_36(val, _values, result); end
  def _reduce_37(val, _values, result); end
  def _reduce_38(val, _values, result); end
  def _reduce_39(val, _values, result); end
  def _reduce_40(val, _values, result); end
  def _reduce_41(val, _values, result); end
  def _reduce_43(val, _values, result); end
  def _reduce_44(val, _values, result); end
  def _reduce_45(val, _values, result); end
  def _reduce_46(val, _values, result); end
  def _reduce_57(val, _values, result); end
  def _reduce_58(val, _values, result); end
  def _reduce_59(val, _values, result); end
  def _reduce_60(val, _values, result); end
  def _reduce_62(val, _values, result); end
  def _reduce_64(val, _values, result); end
  def _reduce_78(val, _values, result); end
  def _reduce_none(val, _values, result); end
  def inline(rdoc, reference = _); end
  def next_token; end
  def next_words_on_error; end
  def on_error(et, ev, values); end
  def parse(inline); end
  def prev_words_on_error(ev); end

  private

  def last_line(src); end
end

RDoc::RD::InlineParser::BACK_SLASH = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::BACK_SLASH_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::BAR = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::BAR_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::CODE_CLOSE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::CODE_CLOSE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::CODE_OPEN = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::CODE_OPEN_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::EM_CLOSE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::EM_CLOSE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::EM_OPEN = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::EM_OPEN_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::FOOTNOTE_CLOSE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::FOOTNOTE_CLOSE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::FOOTNOTE_OPEN = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::FOOTNOTE_OPEN_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::INDEX_CLOSE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::INDEX_CLOSE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::INDEX_OPEN = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::INDEX_OPEN_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::KBD_CLOSE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::KBD_CLOSE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::KBD_OPEN = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::KBD_OPEN_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::OTHER_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::QUOTE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::QUOTE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::REF_CLOSE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::REF_CLOSE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::REF_OPEN = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::REF_OPEN_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::Racc_arg = T.let(T.unsafe(nil), Array)

RDoc::RD::InlineParser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

RDoc::RD::InlineParser::SLASH = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::SLASH_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::URL = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::URL_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::VAR_CLOSE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::VAR_CLOSE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::VAR_OPEN = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::VAR_OPEN_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::VERB_CLOSE = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::VERB_CLOSE_RE = T.let(T.unsafe(nil), Regexp)

RDoc::RD::InlineParser::VERB_OPEN = T.let(T.unsafe(nil), String)

RDoc::RD::InlineParser::VERB_OPEN_RE = T.let(T.unsafe(nil), Regexp)

class RDoc::RDoc
  def initialize; end

  def document(options); end
  def error(msg); end
  def gather_files(files); end
  def generate; end
  def generator; end
  def generator=(_); end
  def handle_pipe; end
  def install_siginfo_handler; end
  def last_modified; end
  def list_files_in_directory(dir); end
  def load_options; end
  def normalized_file_list(relative_files, force_doc = _, exclude_pattern = _); end
  def options; end
  def options=(_); end
  def output_flag_file(op_dir); end
  def parse_dot_doc_file(in_dir, filename); end
  def parse_file(filename); end
  def parse_files(files); end
  def remove_siginfo_handler; end
  def remove_unparseable(files); end
  def setup_output_dir(dir, force); end
  def stats; end
  def store; end
  def store=(store); end
  def update_output_dir(op_dir, time, last = _); end

  def self.add_generator(klass); end
  def self.current; end
  def self.current=(rdoc); end
end

RDoc::RDoc::GENERATORS = T.let(T.unsafe(nil), Hash)

module RDoc::RI
end

class RDoc::RI::Driver
  def initialize(initial_options = _); end

  def add_also_in(out, also_in); end
  def add_class(out, name, classes); end
  def add_extends(out, extends); end
  def add_extension_modules(out, type, extensions); end
  def add_extension_modules_multiple(out, store, modules); end
  def add_extension_modules_single(out, store, include); end
  def add_from(out, store); end
  def add_includes(out, includes); end
  def add_method(out, name); end
  def add_method_documentation(out, klass); end
  def add_method_list(out, methods, name); end
  def ancestors_of(klass); end
  def check_did_you_mean; end
  def class_cache; end
  def class_document(name, found, klasses, includes, extends); end
  def class_document_comment(out, comment); end
  def class_document_constants(out, klass); end
  def classes; end
  def classes_and_includes_and_extends_for(name); end
  def complete(name); end
  def complete_klass(name, klass, selector, method, completions); end
  def complete_method(name, klass, selector, completions); end
  def display(document); end
  def display_class(name); end
  def display_method(name); end
  def display_name(name); end
  def display_names(names); end
  def display_page(name); end
  def display_page_list(store, pages = _, search = _); end
  def expand_class(klass); end
  def expand_name(name); end
  def filter_methods(found, name); end
  def find_methods(name); end
  def find_pager_jruby(pager); end
  def find_store(name); end
  def formatter(io); end
  def in_path?(file); end
  def interactive; end
  def list_known_classes(names = _); end
  def list_methods_matching(name); end
  def load_method(store, cache, klass, type, name); end
  def load_methods_matching(name); end
  def lookup_method(name); end
  def method_document(name, filtered); end
  def method_type(selector); end
  def name_regexp(name); end
  def page; end
  def paging?; end
  def parse_name(name); end
  def render_class(out, store, klass, also_in); end
  def render_method(out, store, method, name); end
  def render_method_arguments(out, arglists); end
  def render_method_comment(out, method, alias_for = _); end
  def render_method_superclass(out, method); end
  def run; end
  def setup_pager; end
  def show_all; end
  def show_all=(_); end
  def start_server; end
  def stores; end
  def stores=(_); end
  def use_stdout; end
  def use_stdout=(_); end

  def self.default_options; end
  def self.dump(data_path); end
  def self.process_args(argv); end
  def self.run(argv = _); end
end

class RDoc::RI::Driver::Error < ::RDoc::RI::Error
end

class RDoc::RI::Driver::NotFoundError < ::RDoc::RI::Driver::Error
  def initialize(klass, suggestions = _); end

  def message; end
  def name; end
end

class RDoc::RI::Error < ::RDoc::Error
end

module RDoc::RI::Paths
  def self.each(system = _, site = _, home = _, gems = _, *extra_dirs); end
  def self.gem_dir(name, version); end
  def self.gemdirs(filter = _); end
  def self.home_dir; end
  def self.path(system = _, site = _, home = _, gems = _, *extra_dirs); end
  def self.raw_path(system, site, home, gems, *extra_dirs); end
  def self.site_dir; end
  def self.system_dir; end
end

RDoc::RI::Paths::BASE = T.let(T.unsafe(nil), String)

RDoc::RI::Paths::HOMEDIR = T.let(T.unsafe(nil), String)

RDoc::RI::Store = RDoc::Store

class RDoc::Require < ::RDoc::CodeObject
  def initialize(name, comment); end

  def inspect; end
  def name; end
  def name=(_); end
  def to_s; end
  def top_level; end
end

class RDoc::Servlet < ::WEBrick::HTTPServlet::AbstractServlet
  def initialize(server, stores, cache, mount_path = _, extra_doc_dirs = _); end

  def asset(generator_name, req, res); end
  def asset_dirs; end
  def do_GET(req, res); end
  def documentation_page(store, generator, path, req, res); end
  def documentation_search(store, generator, req, res); end
  def documentation_source(path); end
  def error(exception, req, res); end
  def generator_for(store); end
  def if_modified_since(req, res, path = _); end
  def installed_docs; end
  def not_found(generator, req, res, message = _); end
  def options; end
  def ri_paths(&block); end
  def root(req, res); end
  def root_search(req, res); end
  def show_documentation(req, res); end
  def store_for(source_name); end

  def self.get_instance(server, *options); end
end

class RDoc::SingleClass < ::RDoc::ClassModule
  def ancestors; end
  def aref_prefix; end
  def definition; end
end

class RDoc::Stats
  include(::RDoc::Text)

  def initialize(store, num_files, verbosity = _); end

  def add_alias(as); end
  def add_attribute(attribute); end
  def add_class(klass); end
  def add_constant(constant); end
  def add_file(file); end
  def add_method(method); end
  def add_module(mod); end
  def begin_adding; end
  def calculate; end
  def coverage_level; end
  def coverage_level=(level); end
  def doc_stats(collection); end
  def done_adding; end
  def files_so_far; end
  def fully_documented?; end
  def great_job; end
  def num_files; end
  def percent_doc; end
  def report; end
  def report_attributes(cm); end
  def report_class_module(cm); end
  def report_constants(cm); end
  def report_methods(cm); end
  def summary; end
  def undoc_params(method); end
end

class RDoc::Stats::Normal < ::RDoc::Stats::Quiet
  def begin_adding; end
  def done_adding; end
  def print_file(files_so_far, filename); end
end

class RDoc::Stats::Quiet
  def initialize(num_files); end

  def begin_adding(*_); end
  def done_adding(*_); end
  def print_alias(*_); end
  def print_attribute(*_); end
  def print_class(*_); end
  def print_constant(*_); end
  def print_file(*_); end
  def print_method(*_); end
  def print_module(*_); end
end

class RDoc::Stats::Verbose < ::RDoc::Stats::Normal
  def nodoc(co); end
  def print_alias(as); end
  def print_attribute(attribute); end
  def print_class(klass); end
  def print_constant(constant); end
  def print_file(files_so_far, file); end
  def print_method(method); end
  def print_module(mod); end
end

class RDoc::Store
  def initialize(path = _, type = _); end

  def add_c_enclosure(variable, namespace); end
  def add_c_variables(c_parser); end
  def add_file(absolute_name, relative_name: _, parser: _); end
  def all_classes; end
  def all_classes_and_modules; end
  def all_files; end
  def all_modules; end
  def ancestors; end
  def attributes; end
  def c_class_variables; end
  def c_enclosure_classes; end
  def c_enclosure_names; end
  def c_singleton_class_variables; end
  def cache; end
  def cache_path; end
  def class_file(klass_name); end
  def class_methods; end
  def class_path(klass_name); end
  def classes_hash; end
  def clean_cache_collection(collection); end
  def complete(min_visibility); end
  def dry_run; end
  def dry_run=(_); end
  def encoding; end
  def encoding=(_); end
  def files_hash; end
  def find_c_enclosure(variable); end
  def find_class_named(name); end
  def find_class_named_from(name, from); end
  def find_class_or_module(name); end
  def find_file_named(name); end
  def find_module_named(name); end
  def find_text_page(file_name); end
  def find_unique(all_hash); end
  def fix_basic_object_inheritance; end
  def friendly_path; end
  def inspect; end
  def instance_methods; end
  def load_all; end
  def load_cache; end
  def load_class(klass_name); end
  def load_class_data(klass_name); end
  def load_method(klass_name, method_name); end
  def load_page(page_name); end
  def main; end
  def main=(page); end
  def make_variable_map(variables); end
  def method_file(klass_name, method_name); end
  def module_names; end
  def modules_hash; end
  def page(name); end
  def page_file(page_name); end
  def path; end
  def path=(_); end
  def rdoc; end
  def rdoc=(_); end
  def remove_nodoc(all_hash); end
  def save; end
  def save_cache; end
  def save_class(klass); end
  def save_method(klass, method); end
  def save_page(page); end
  def source; end
  def title; end
  def title=(title); end
  def type; end
  def type=(_); end
  def unique_classes; end
  def unique_classes_and_modules; end
  def unique_modules; end
  def unmatched_constant_alias; end
  def update_parser_of_file(absolute_name, parser); end
end

class RDoc::Store::Error < ::RDoc::Error
end

class RDoc::Store::MissingFileError < ::RDoc::Store::Error
  def initialize(store, file, name); end

  def file; end
  def message; end
  def name; end
  def store; end
end

class RDoc::Task < ::Rake::TaskLib
  def initialize(name = _); end

  def before_running_rdoc(&block); end
  def check_names(names); end
  def clobber_task_description; end
  def defaults; end
  def define; end
  def external; end
  def external=(_); end
  def generator; end
  def generator=(_); end
  def inline_source; end
  def inline_source=(value); end
  def main; end
  def main=(_); end
  def markup; end
  def markup=(_); end
  def name; end
  def name=(_); end
  def option_list; end
  def options; end
  def options=(_); end
  def rdoc_dir; end
  def rdoc_dir=(_); end
  def rdoc_files; end
  def rdoc_files=(_); end
  def rdoc_task_description; end
  def rerdoc_task_description; end
  def template; end
  def template=(_); end
  def title; end
  def title=(_); end

  private

  def clobber_task_name; end
  def rdoc_target; end
  def rdoc_task_name; end
  def rerdoc_task_name; end
end

module RDoc::Text
  def expand_tabs(text); end
  def flush_left(text); end
  def language; end
  def language=(_); end
  def markup(text); end
  def normalize_comment(text); end
  def parse(text, format = _); end
  def snippet(text, limit = _); end
  def strip_hashes(text); end
  def strip_newlines(text); end
  def strip_stars(text); end
  def to_html(text); end
  def wrap(txt, line_len = _); end

  def self.encode_fallback(character, encoding, fallback); end
end

RDoc::Text::MARKUP_FORMAT = T.let(T.unsafe(nil), Hash)

RDoc::Text::TO_HTML_CHARACTERS = T.let(T.unsafe(nil), Hash)

module RDoc::TokenStream
  def add_token(token); end
  def add_tokens(tokens); end
  def collect_tokens; end
  def pop_token; end
  def start_collecting_tokens; end
  def token_stream; end
  def tokens_to_s; end

  def self.to_html(token_stream); end
end

class RDoc::TomDoc < ::RDoc::Markup::Parser
  def initialize; end

  def build_heading(level); end
  def build_paragraph(margin); end
  def build_verbatim(margin); end
  def parse_text(parent, indent); end
  def tokenize(text); end
  def tokens; end

  def self.add_post_processor; end
  def self.parse(text); end
  def self.signature(comment); end
end

class RDoc::TopLevel < ::RDoc::Context
  def initialize(absolute_name, relative_name = _); end

  def ==(other); end
  def absolute_name; end
  def absolute_name=(_); end
  def add_alias(an_alias); end
  def add_constant(constant); end
  def add_include(include); end
  def add_method(method); end
  def add_to_classes_or_modules(mod); end
  def base_name; end
  def classes_or_modules; end
  def cvs_url; end
  def diagram; end
  def diagram=(_); end
  def display?; end
  def eql?(other); end
  def file_stat; end
  def file_stat=(_); end
  def find_class_or_module(name); end
  def find_local_symbol(symbol); end
  def find_module_named(name); end
  def full_name; end
  def hash; end
  def http_url(prefix); end
  def inspect; end
  def last_modified; end
  def marshal_dump; end
  def marshal_load(array); end
  def name; end
  def object_class; end
  def page_name; end
  def parser; end
  def parser=(val); end
  def path; end
  def pretty_print(q); end
  def relative_name; end
  def relative_name=(_); end
  def search_record; end
  def text?; end
  def to_s; end
end

RDoc::TopLevel::MARSHAL_VERSION = T.let(T.unsafe(nil), Integer)

RDoc::VERSION = T.let(T.unsafe(nil), String)

RDoc::VISIBILITIES = T.let(T.unsafe(nil), Array)

module RDoc::RI::Formatter
end

module Rake
  extend(::Rake::FileUtilsExt)
  extend(::FileUtils)
  extend(::FileUtils::StreamUtils_)

  def self.add_rakelib(*files); end
  def self.application; end
  def self.application=(app); end
  def self.each_dir_parent(dir); end
  def self.from_pathname(path); end
  def self.load_rakefile(path); end
  def self.original_dir; end
  def self.suggested_thread_count; end
  def self.with_application(block_application = _); end
end

class Rake::CommandLineOptionError < ::StandardError
end

Rake::EARLY = T.let(T.unsafe(nil), Rake::EarlyTime)

Rake::EMPTY_TASK_ARGS = T.let(T.unsafe(nil), Rake::TaskArguments)

Rake::LATE = T.let(T.unsafe(nil), Rake::LateTime)

Rake::RDocTask = RDoc::Task

Rake::VERSION = T.let(T.unsafe(nil), String)
